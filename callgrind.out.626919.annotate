--------------------------------------------------------------------------------
Profile data file 'callgrind.out.626919' (creator: callgrind-3.19.0)
--------------------------------------------------------------------------------
I1 cache: 32768 B, 64 B, 8-way associative
D1 cache: 32768 B, 64 B, 8-way associative
LL cache: 268435456 B, 64 B, direct-mapped
Timerange: Basic block 0 - 1439446625
Trigger: Program termination
Profiled target:  target/release/tarjim -n 20250823_fixedUpFinalReal_ArgR_D_0 -i /work/hdd/bbgs/alimf//AlterProcessedData/ArgROutput_min_height_3.0.bin -o ../20250823_fixedUpFinalReal_ArgR -a 2 -b 0.015625 -t 0 -s 1 (PID 626919, part 1)
Events recorded:  Ir Dr Dw I1mr D1mr D1mw ILmr DLmr DLmw
Events shown:     Ir Dr Dw I1mr D1mr D1mw ILmr DLmr DLmw
Event sort order: Ir Dr Dw I1mr D1mr D1mw ILmr DLmr DLmw
Thresholds:       99 0 0 0 0 0 0 0 0
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                      Dr                     Dw                   I1mr           D1mr                D1mw               ILmr           DLmr            DLmw               
--------------------------------------------------------------------------------
10,439,396,572 (100.0%) 1,854,778,367 (100.0%) 969,656,262 (100.0%) 6,899 (100.0%) 52,441,204 (100.0%) 6,739,086 (100.0%) 4,051 (100.0%) 40,736 (100.0%) 2,287,914 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                     Dr                   Dw                   I1mr         D1mr                D1mw               ILmr         DLmr            DLmw                file:function
--------------------------------------------------------------------------------
2,066,342,176 (19.79%) 149,293,645 ( 8.05%)  24,653,782 ( 2.54%)  48 ( 0.70%)      2,353 ( 0.00%)        49 ( 0.00%)  48 ( 1.18%)     10 ( 0.02%)         .           src/sequence.rs:tarjim::main
1,803,149,575 (17.27%) 554,113,594 (29.87%) 304,212,755 (31.37%) 188 ( 2.73%)      3,720 ( 0.01%)     1,014 ( 0.02%)  26 ( 0.64%)  1,168 ( 2.87%)       117 ( 0.01%)  ???:_int_free [/usr/lib64/libc-2.28.so]
1,327,124,243 (12.71%) 331,475,409 (17.87%) 165,125,102 (17.03%)  15 ( 0.22%)      1,256 ( 0.00%)       202 ( 0.00%)   6 ( 0.15%)     66 ( 0.16%)        30 ( 0.00%)  ???:malloc [/usr/lib64/libc-2.28.so]
  633,036,592 ( 6.06%) 165,143,186 ( 8.90%)  27,523,922 ( 2.84%) 107 ( 1.55%)      1,720 ( 0.00%)         0            4 ( 0.10%)    532 ( 1.31%)         .           ???:free [/usr/lib64/libc-2.28.so]
  402,497,574 ( 3.86%)  45,322,126 ( 2.44%)  12,178,117 ( 1.26%)   9 ( 0.13%)        558 ( 0.00%)        27 ( 0.00%)   9 ( 0.22%)      0                  1 ( 0.00%)  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/iter/range.rs:tarjim::main
  313,444,381 ( 3.00%)  44,782,815 ( 2.41%) 130,156,179 (13.42%)  17 ( 0.25%) 25,797,297 (49.19%) 4,309,845 (63.95%)  16 ( 0.39%)      1 ( 0.00%)   673,381 (29.43%)  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ptr/mod.rs:tarjim::main
  284,832,150 ( 2.73%)           0                    5 ( 0.00%)   9 ( 0.13%)          0                  0            9 ( 0.22%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/num/uint_macros.rs:tarjim::main
  280,955,192 ( 2.69%)  86,825,067 ( 4.68%)  63,410,279 ( 6.54%) 207 ( 3.00%)    219,421 ( 0.42%)   221,002 ( 3.28%)  12 ( 0.30%)    602 ( 1.48%)    40,231 ( 1.76%)  ???:__memcpy_avx_unaligned_erms [/usr/lib64/libc-2.28.so]
  273,530,887 ( 2.62%)  63,707,866 ( 3.43%)  12,176,932 ( 1.26%)  17 ( 0.25%)    224,205 ( 0.43%)         1 ( 0.00%)  17 ( 0.42%)  4,766 (11.70%)         .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/slice/iter/macros.rs:tarjim::main
  257,662,870 ( 2.47%)           0                    0            3 ( 0.04%)          0                  0            3 ( 0.07%)      .                  .           /u/alimf/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/wyhash2-0.2.1/src/lib.rs:tarjim::main
  256,933,320 ( 2.46%)  28,886,650 ( 1.56%)  16,469,412 ( 1.70%)   8 ( 0.12%)        120 ( 0.00%)       401 ( 0.01%)   8 ( 0.20%)      .                  .           /rust/deps/hashbrown-0.15.4/src/raw/mod.rs:tarjim::main
  214,216,243 ( 2.05%)  50,290,689 ( 2.71%)  50,290,704 ( 5.19%)   4 ( 0.06%)        148 ( 0.00%)         0            4 ( 0.10%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/std/src/sys/alloc/unix.rs:tarjim::main
  196,316,112 ( 1.88%)  12,176,915 ( 0.66%)           0            2 ( 0.03%)          0                  0            2 ( 0.05%)      .                  .           /rust/deps/hashbrown-0.15.4/src/control/tag.rs:tarjim::main
  140,122,322 ( 1.34%)  27,519,610 ( 1.48%)         222 ( 0.00%)  12 ( 0.17%)          1 ( 0.00%)        29 ( 0.00%)  12 ( 0.30%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/alloc/src/raw_vec/mod.rs:tarjim::main
  128,219,156 ( 1.23%)           0                    0            2 ( 0.03%)          0                  0            2 ( 0.05%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/num/uint_macros.rs:core::hash::BuildHasher::hash_one
  121,779,913 ( 1.17%)  48,707,744 ( 2.63%)           0            4 ( 0.06%)         26 ( 0.00%)         0            4 ( 0.10%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/slice/index.rs:tarjim::main
  110,392,913 ( 1.06%)   6,331,000 ( 0.34%)   9,496,500 ( 0.98%)   3 ( 0.04%)        187 ( 0.00%)        12 ( 0.00%)   3 ( 0.07%)      .                  .           src/sequence.rs:motif_finder::sequence::Sequence::return_bases [/u/alimf/motif_finder_project/motif_finder/target/release/tarjim]
  108,365,600 ( 1.04%)           1 ( 0.00%)           0            3 ( 0.04%)          0                  0            3 ( 0.07%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ptr/mut_ptr.rs:tarjim::main
   97,523,269 ( 0.93%)   4,645,125 ( 0.25%)           0            4 ( 0.06%)     13,935 ( 0.03%)         0            4 ( 0.10%)      1 ( 0.00%)         .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/../../stdarch/crates/core_arch/src/x86/sse2.rs:tarjim::main
   96,765,240 ( 0.93%)  60,167,430 ( 3.24%)         196 ( 0.00%)   7 ( 0.10%) 23,363,906 (44.55%)         1 ( 0.00%)   7 ( 0.17%)  3,413 ( 8.38%)         .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/cmp.rs:tarjim::main
   81,369,849 ( 0.78%)           0                    0            3 ( 0.04%)          0                  0            3 ( 0.07%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/hash/sip.rs:core::hash::BuildHasher::hash_one
   73,061,730 ( 0.70%)  12,176,918 ( 0.66%)  12,176,917 ( 1.26%)   2 ( 0.03%)         27 ( 0.00%)         1 ( 0.00%)   2 ( 0.05%)      0                  1 ( 0.00%)  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/alloc/layout.rs:tarjim::main
   68,440,792 ( 0.66%)   4,874,339 ( 0.26%)   9,744,907 ( 1.00%)  11 ( 0.16%)    680,851 ( 1.30%)       406 ( 0.01%)  11 ( 0.27%)      1 ( 0.00%)         .           /rust/deps/hashbrown-0.15.4/src/raw/mod.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash [/u/alimf/motif_finder_project/motif_finder/target/release/tarjim]
   67,461,227 ( 0.65%)  16,462,964 ( 0.89%)  34,667,638 ( 3.58%)  21 ( 0.30%)    161,139 ( 0.31%)     5,374 ( 0.08%)  21 ( 0.52%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ptr/mod.rs:core::slice::sort::unstable::quicksort::quicksort'2
   66,121,834 ( 0.63%)     138,735 ( 0.01%)           0            2 ( 0.03%)          0                  0            2 ( 0.05%)      .                  .           /rust/deps/hashbrown-0.15.4/src/control/bitmask.rs:tarjim::main
   62,770,661 ( 0.60%)           0                    0            2 ( 0.03%)          0                  0            2 ( 0.05%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/intrinsics/mod.rs:tarjim::main
   57,159,238 ( 0.55%)  15,937,646 ( 0.86%)     489,217 ( 0.05%)   0             742,346 ( 1.42%)     2,038 ( 0.03%)   .               .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/slice/sort/unstable/quicksort.rs:core::slice::sort::unstable::quicksort::quicksort'2 [/u/alimf/motif_finder_project/motif_finder/target/release/tarjim]
   52,990,936 ( 0.51%)   8,091,373 ( 0.44%)   8,830,256 ( 0.91%) 133 ( 1.93%)      2,731 ( 0.01%)     3,221 ( 0.05%)  52 ( 1.28%)    314 ( 0.77%)     2,074 ( 0.09%)  ???:_int_malloc [/usr/lib64/libc-2.28.so]
   46,688,998 ( 0.45%)   3,165,500 ( 0.17%)  21,761,749 ( 2.24%)   1 ( 0.01%)          0                102 ( 0.00%)   1 ( 0.02%)      0                  1 ( 0.00%)  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ptr/mod.rs:motif_finder::sequence::Sequence::return_bases
   45,899,373 ( 0.44%)           0                    0            1 ( 0.01%)          0                  0            1 ( 0.02%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/hash/sip.rs:tarjim::main
   45,183,233 ( 0.43%)   5,829,173 ( 0.31%)   5,649,780 ( 0.58%)   3 ( 0.04%)        228 ( 0.00%)       127 ( 0.00%)   3 ( 0.07%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ptr/non_null.rs:tarjim::main
   37,984,582 ( 0.36%)   9,891,833 ( 0.53%)           0            1 ( 0.01%)      8,718 ( 0.02%)         0            1 ( 0.02%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/slice/iter/macros.rs:motif_finder::sequence::Sequence::return_bases
   36,647,719 ( 0.35%)      69,611 ( 0.00%)           0            1 ( 0.01%)         41 ( 0.00%)         0            1 ( 0.02%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/cmp.rs:core::slice::sort::unstable::quicksort::quicksort'2
   36,531,402 ( 0.35%)  12,177,210 ( 0.66%)          96 ( 0.00%)   7 ( 0.10%)        270 ( 0.00%)        14 ( 0.00%)   7 ( 0.17%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/std/src/collections/hash/map.rs:tarjim::main
   36,524,332 ( 0.35%)           .                    .            .                   .                  .            .               .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ops/index_range.rs:tarjim::main
   27,178,744 ( 0.26%)           .                    .            .                   .                  .            .               .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/convert/num.rs:tarjim::main
   26,906,750 ( 0.26%)           0            3,165,500 ( 0.33%)   0                   0                 12 ( 0.00%)   .               .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/slice/index.rs:motif_finder::sequence::Sequence::return_bases
   24,657,400 ( 0.24%)   9,862,960 ( 0.53%)   2,465,740 ( 0.25%)   0             347,327 ( 0.66%)         .            .               .                  .           /rust/deps/hashbrown-0.15.4/src/map.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash
   24,353,844 ( 0.23%)           0                    0            1 ( 0.01%)          0                  0            1 ( 0.02%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ptr/const_ptr.rs:tarjim::main
   24,040,712 ( 0.23%)           .                    .            .                   .                  .            .               .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/num/nonzero.rs:tarjim::main
   23,741,250 ( 0.23%)  14,244,750 ( 0.77%)   3,165,500 ( 0.33%)   2 ( 0.03%)         41 ( 0.00%)         0            2 ( 0.05%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/std/src/sys/alloc/unix.rs:motif_finder::sequence::Sequence::return_bases
   21,952,454 ( 0.21%)   2,465,516 ( 0.13%)         214 ( 0.00%)   .                   .                  .            .               .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/intrinsics/mod.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash
   20,877,577 ( 0.20%)         406 ( 0.00%)         609 ( 0.00%)   2 ( 0.03%)         47 ( 0.00%)        47 ( 0.00%)   2 ( 0.05%)      .                  .           /rust/deps/hashbrown-0.15.4/src/control/bitmask.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash
   20,338,535 ( 0.19%)   2,636,572 ( 0.14%)   1,244,721 ( 0.13%)  65 ( 0.94%)     25,986 ( 0.05%)    17,263 ( 0.26%)  52 ( 1.28%) 19,762 (48.51%)    17,251 ( 0.75%)  /u/alimf/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libdeflate-sys-1.24.0/libdeflate/lib/x86/../decompress_template.h:deflate_decompress_bmi2 [/u/alimf/motif_finder_project/motif_finder/target/release/tarjim]
   19,486,872 ( 0.19%)   9,743,310 ( 0.53%)   4,872,024 ( 0.50%)   3 ( 0.04%)    171,501 ( 0.33%) 1,852,684 (27.49%)   3 ( 0.07%)      0          1,318,701 (57.64%)  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ptr/mod.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash
   19,242,496 ( 0.18%)           .                    .            .                   .                  .            .               .                  .           /u/alimf/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/wyhash2-0.2.1/src/lib.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash
   17,973,548 ( 0.17%)   8,986,219 ( 0.48%)   1,583,229 ( 0.16%)  11 ( 0.16%)        226 ( 0.00%)        18 ( 0.00%)  11 ( 0.27%)      0                  1 ( 0.00%)  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/alloc/src/vec/mod.rs:tarjim::main
   17,517,395 ( 0.17%)       1,147 ( 0.00%)  17,505,764 ( 1.81%)  15 ( 0.22%)         84 ( 0.00%)   274,490 ( 4.07%)   6 ( 0.15%)      0            217,404 ( 9.50%)  ???:__memset_avx2_unaligned_erms [/usr/lib64/libc-2.28.so]
   17,410,250 ( 0.17%)   1,582,750 ( 0.09%)   1,582,750 ( 0.16%)   .                   .                  .            .               .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/alloc/src/raw_vec/mod.rs:motif_finder::sequence::Sequence::return_bases
   17,410,250 ( 0.17%)   1,582,750 ( 0.09%)   1,582,750 ( 0.16%)   .                   .                  .            .               .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/alloc/layout.rs:motif_finder::sequence::Sequence::return_bases
   16,493,896 ( 0.16%)   3,218,178 ( 0.17%)   2,824,916 ( 0.29%)   2 ( 0.03%)        133 ( 0.00%)        49 ( 0.00%)   2 ( 0.05%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/alloc/src/vec/into_iter.rs:tarjim::main
   15,469,887 ( 0.15%)   4,590,166 ( 0.25%)     451,420 ( 0.05%)   2 ( 0.03%)          0              3,523 ( 0.05%)   2 ( 0.05%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/slice/sort/shared/smallsort.rs:core::slice::sort::unstable::quicksort::quicksort'2
   14,244,750 ( 0.14%)           0                    0            2 ( 0.03%)          0                  0            2 ( 0.05%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/num/uint_macros.rs:motif_finder::sequence::Sequence::return_bases
    9,969,440 ( 0.10%)           0                    0            2 ( 0.03%)          0                  0            2 ( 0.05%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ptr/mut_ptr.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash
    9,742,104 ( 0.09%)   4,871,052 ( 0.26%)           0            0                  11 ( 0.00%)         .            .               .                  .           /rust/deps/hashbrown-0.15.4/src/control/tag.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash
    9,530,140 ( 0.09%)   2,721,859 ( 0.15%)         224 ( 0.00%)   5 ( 0.07%)    333,737 ( 0.64%)        65 ( 0.00%)   5 ( 0.12%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/slice/sort/unstable/quicksort.rs:core::slice::sort::unstable::quicksort::quicksort [/u/alimf/motif_finder_project/motif_finder/target/release/tarjim]
    8,170,708 ( 0.08%)   2,722,536 ( 0.15%)   5,444,641 ( 0.56%)   1 ( 0.01%)    147,362 ( 0.28%)        31 ( 0.00%)   1 ( 0.02%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ptr/mod.rs:core::slice::sort::unstable::quicksort::quicksort
    7,280,158 ( 0.07%)           0                    0            5 ( 0.07%)          0                  0            5 ( 0.12%)      .                  .           /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/num/uint_macros.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash

--------------------------------------------------------------------------------
-- Auto-annotated source: src/sequence.rs
--------------------------------------------------------------------------------
Ir                   Dr                   Dw                  I1mr        D1mr           D1mw        ILmr        DLmr       DLmw 

-- line 160 ----------------------------------------
          .                    .                   .           .              .           .           .          .          .               /// - If `positive_window_parts` has a length not equal to the length of blocks
          .                    .                   .           .              .           .           .          .          .               /// - If any element of `block_lens` is not divisible by `[BP_PER_U8]` 
          .                    .                   .           .              .           .           .          .          .               /// - If any element of `block_lens` is not greater than `[MAX_BASE]`
          .                    .                   .           .              .           .           .          .          .               /// - If the sum of `block_lens` is not equal to `[BP_PER_U8] * seq_blocks.len()`
          .                    .                   .           .              .           .           .          .          .               pub fn new_manual(seq_blocks: Vec<u8>, block_lens: Vec<usize>, positive_window_slices: &[(usize, usize, usize)]) -> Sequence {
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   //if positive_window_parts.len() != block_lens.len() { panic!("poor alignment of window indicators!");}
          .                    .                   .           .              .           .           .          .          .                   
          1 ( 0.00%)           0                   1 ( 0.00%)  .              .           .           .          .          .                   let mut block_u8_starts: Vec<usize> = vec![0];
          .                    .                   .           .              .           .           .          .          .           
        100 ( 0.00%)           .                   .           .              .           .           .          .          .                   for i in 0..(block_lens.len()-1) {
        372 ( 0.00%)          93 ( 0.00%)          0           1 ( 0.01%)     0           0           1 ( 0.02%) .          .                       if block_lens[i] > MAX_BASE && block_lens[i] % BP_PER_U8 == 0{
        186 ( 0.00%)          93 ( 0.00%)          .           .              .           .           .          .          .                           block_u8_starts.push(block_u8_starts[i]+block_lens[i]/BP_PER_U8);
          .                    .                   .           .              .           .           .          .          .                       } else {
          .                    .                   .           .              .           .           .          .          .                           panic!("All blocks must be longer than your maximum possible motif size and divisible by {}!", BP_PER_U8);
          .                    .                   .           .              .           .           .          .          .                       }
          .                    .                   .           .              .           .           .          .          .                   }
          .                    .                   .           .              .           .           .          .          .           
          2 ( 0.00%)           1 ( 0.00%)          .           .              .           .           .          .          .                   if block_lens.iter().map(|b| b/BP_PER_U8).sum::<usize>() != seq_blocks.len() {
          .                    .                   .           .              .           .           .          .          .                       panic!("stated block lengths do not equal the length of your data!");
          .                    .                   .           .              .           .           .          .          .                   }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   const F: Vec<u64> = Vec::new();
          .                    .                   .           .              .           .           .          .          .           
          1 ( 0.00%)           1 ( 0.00%)          0           1 ( 0.01%)     0           0           1 ( 0.02%) .          .                   let max_len: usize = *block_lens.iter().max().unwrap();
          .                    .                   .           .              .           .           .          .          .                   let orig_dict: [Vec<u64>; MAX_BASE+1-MIN_BASE] = [F; MAX_BASE+1-MIN_BASE];
          .                    .                   .           .              .           .           .          .          .                   let orig_nums = [0_usize; MAX_BASE+1-MIN_BASE];
          .                    .                   .           .              .           .           .          .          .                   let orig_id_dict: Vec<HashMap<u64, usize, WyHash>> = Vec::new();
          .                    .                   .           .              .           .           .          .          .           
         32 ( 0.00%)           8 ( 0.00%)         20 ( 0.00%)  3 ( 0.04%)     0           2 ( 0.00%)  3 ( 0.07%) .          .                   let mut seq = Sequence{
          .                    .                   .           .              .           .           .          .          .                               seq_blocks: seq_blocks,
          2 ( 0.00%)           2 ( 0.00%)          0           1 ( 0.01%)     0           0           1 ( 0.02%) .          .                               block_u8_starts: block_u8_starts,
          .                    .                   .           .              .           .           .          .          .                               block_lens: block_lens,
          .                    .                   .           .              .           .           .          .          .                               positive_window_slices: positive_window_slices.to_vec(),
          .                    .                   .           .              .           .           .          .          .                               max_len: max_len,
          2 ( 0.00%)           0                   1 ( 0.00%)  .              .           .           .          .          .                               kmer_dict: orig_dict, 
         60 ( 0.00%)          16 ( 0.00%)         13 ( 0.00%)  3 ( 0.04%)     0           6 ( 0.00%)  .          .          .           => ???:__memcpy_avx_unaligned_erms (1x)
          5 ( 0.00%)           3 ( 0.00%)          2 ( 0.00%)  1 ( 0.01%)     0           0           1 ( 0.02%) .          .                               kmer_id_dict: orig_id_dict,
          .                    .                   .           .              .           .           .          .          .                               kmer_nums: orig_nums,
          .                    .                   .           .              .           .           .          .          .                   };
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   seq.initialize_kmer_dicts();
         15 ( 0.00%)           9 ( 0.00%)          2 ( 0.00%)  2 ( 0.03%)     1 ( 0.00%)  0           2 ( 0.05%) .          .                   seq
         74 ( 0.00%)          20 ( 0.00%)         17 ( 0.00%)  0              0           8 ( 0.00%)  .          .          .           => ???:__memcpy_avx_unaligned_erms (1x)
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               fn agglutinate_windows(seq_lens: &[usize], positive_window_parts: &[Vec<usize>]) -> Vec<(usize, usize, usize)> {
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   if positive_window_parts.len() == 0 { return Vec::new();}
          .                    .                   .           .              .           .           .          .          .                   let mut windows: Vec<(usize, usize, usize)> = Vec::with_capacity(positive_window_parts.len()*positive_window_parts[0].len());
          .                    .                   .           .              .           .           .          .          .           
-- line 209 ----------------------------------------
-- line 324 ----------------------------------------
          .                    .                   .           .              .           .           .          .          .               fn initialize_kmer_dicts(&mut self) {
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   let mut kmer_dict: [Vec<u64>; MAX_BASE+1-MIN_BASE] = core::array::from_fn(|_a| {
          .                    .                   .           .              .           .           .          .          .                       Vec::new()
          .                    .                   .           .              .           .           .          .          .                   });
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   let mut kmer_id_dict: Vec<HashMap<u64, usize, WyHash>> = Vec::with_capacity(MAX_BASE+1-MIN_BASE);
          .                    .                   .           .              .           .           .          .          .           
         12 ( 0.00%)           0                   9 ( 0.00%)  1 ( 0.01%)     0           2 ( 0.00%)  1 ( 0.02%) .          .                   let mut kmer_nums = [0_usize; MAX_BASE+1-MIN_BASE]; 
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   for k in MIN_BASE..MAX_BASE+1 {
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                       let kmer_arr = self.generate_kmers(k);
          .                    .                   .           .              .           .           .          .          .                       let hasher = WyHash::with_seed(0);
          .                    .                   .           .              .           .           .          .          .                       let mut minimap: HashMap<u64, usize, _> = HashMap::with_capacity_and_hasher(kmer_arr.len(), hasher);
          .                    .                   .           .              .           .           .          .          .                       let _ = kmer_arr.iter().enumerate().map(|(a, &b)| minimap.insert(b, a)).collect::<Vec<_>>();
          .                    .                   .           .              .           .           .          .          .                       kmer_id_dict.push(minimap);
         13 ( 0.00%)           0                  13 ( 0.00%)  0              0          13 ( 0.00%)  .          .          .                       kmer_nums[k-MIN_BASE] =  kmer_arr.len();
         91 ( 0.00%)           0                  39 ( 0.00%)  0              0           4 ( 0.00%)  .          .          .                       kmer_dict[k-MIN_BASE] =  kmer_arr;
          .                    .                   .           .              .           .           .          .          .                   }
          .                    .                   .           .              .           .           .          .          .           
          6 ( 0.00%)           1 ( 0.00%)          2 ( 0.00%)  1 ( 0.01%)     1 ( 0.00%)  0           1 ( 0.02%) .          .                   self.kmer_dict = kmer_dict;
         61 ( 0.00%)          16 ( 0.00%)         13 ( 0.00%)  0              6 ( 0.00%)  .           .          .          .           => ???:__memcpy_avx_unaligned_erms (1x)
         30 ( 0.00%)          15 ( 0.00%)          1 ( 0.00%)  4 ( 0.06%)     6 ( 0.00%)  0           4 ( 0.10%) .          .           => /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<[alloc::vec::Vec<u64>; 13]> (1x)
          5 ( 0.00%)           2 ( 0.00%)          2 ( 0.00%)  1 ( 0.01%)     0           0           1 ( 0.02%) .          .                   self.kmer_id_dict = kmer_id_dict;
         14 ( 0.00%)           7 ( 0.00%)          7 ( 0.00%)  1 ( 0.01%)     1 ( 0.00%)  2 ( 0.00%)  1 ( 0.02%) .          .                   self.kmer_nums = kmer_nums;
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               fn generate_kmers(&self, len: usize) -> Vec<u64> {
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   let mut unel: Vec<u64> = Vec::new();
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   /*for i in 0..self.block_lens.len() {
-- line 355 ----------------------------------------
-- line 359 ----------------------------------------
          .                    .                   .           .              .           .           .          .          .                           for j in 0..(self.block_lens[i]-len+1){
          .                    .                   .           .              .           .           .          .          .                               unel.push(Self::kmer_to_u64(&self.return_bases(i, j, len)));
          .                    .                   .           .              .           .           .          .          .                           }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                       }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   }*/
          .                    .                   .           .              .           .           .          .          .           
     13,650 ( 0.00%)      13,650 ( 0.00%)          0           1 ( 0.01%) 1,819 ( 0.00%)  0           1 ( 0.02%) .          .                   for &(block_of, start, end) in self.positive_window_slices.iter() {
          .                    .                   .           .              .           .           .          .          .           
     13,650 ( 0.00%)       4,550 ( 0.00%)          0           0            168 ( 0.00%)  .           .          .          .                       if self.block_lens[block_of] >= len {
          .                    .                   .           .              .           .           .          .          .                           for j in start..=end {
  9,496,500 ( 0.09%)   3,165,500 ( 0.17%)  1,582,750 ( 0.16%)  1 ( 0.01%)    16 ( 0.00%)  0           1 ( 0.02%) .          .                               unel.push(Self::kmer_to_u64(&self.return_bases(block_of, j, len)));
711,684,580 ( 6.82%) 144,791,176 ( 7.81%) 102,847,584 (10.61%) 10 ( 0.14%) 9,246 ( 0.02%) 217 ( 0.00%) 10 ( 0.25%) 0          2 ( 0.00%)  => src/sequence.rs:motif_finder::sequence::Sequence::return_bases (1,582,750x)
          .                    .                   .           .              .           .           .          .          .                           }
          .                    .                   .           .              .           .           .          .          .                       }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   }
          .                    .                   .           .              .           .           .          .          .           
        104 ( 0.00%)          26 ( 0.00%)         39 ( 0.00%)  2 ( 0.03%)     0          13 ( 0.00%)  2 ( 0.05%) .          .                   unel = unel.into_iter().unique().collect();
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   unel.sort_unstable(); // we filtered uniquely, so unstable sorting doesn't matter
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   unel.shrink_to_fit();
          .                    .                   .           .              .           .           .          .          .           
         26 ( 0.00%)          26 ( 0.00%)          0           1 ( 0.01%)     0           0           1 ( 0.02%) .          .                   unel
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               //Regular reader functions
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               /// # Panics
-- line 391 ----------------------------------------
-- line 486 ----------------------------------------
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   let mut reference: u8 = coded;
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   for i in 0..BP_PER_U8 { 
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                       //SAFETY: U8_BITMASK always chops the last two bits from the u8, leaving a usize < BASE_L (4)
          .                    .                   .           .              .           .           .          .          .                       // BIG HUGE ENORMOUS SAFETY NOTE WARNING: IF YOU AT ANY POINT CHANGE THE NUMBER OF BPS THAT WE HAVE,
          .                    .                   .           .              .           .           .          .          .                       // THIS IS THE FUNCTION AND THE PLACE WHERE YOU WILL GET UB IF YOU ARE NOT EXTREMELY CAREFUL
259,503,990 ( 2.49%)           .                   .           .              .           .           .          .          .                       v[i] = unsafe{Bp::usize_to_bp((U8_BITMASK & reference) as usize)};
216,253,325 ( 2.07%)           0                   0           1 ( 0.01%)     0           0           1 ( 0.02%) .          .                       reference = reference >> 2; 
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   v
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               pub(crate) fn kmer_to_u64(bases: &[Bp]) -> u64 {
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   let mut mot : u64 = 0;
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   for i in 0..bases.len() {
451,669,605 ( 4.33%) 109,564,815 ( 5.91%)          0           4 ( 0.06%)     0           0           4 ( 0.10%) .          .                       mot += (bases[i] as usize as u64) << (i*BITS_PER_BP);
          .                    .                   .           .              .           .           .          .          .                   }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   mot
          .                    .                   .           .              .           .           .          .          .               }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               //Precision: This has no way to know whether you have the right kmer length.
          .                    .                   .           .              .           .           .          .          .               //        Ensure you match the correct kmer length to this u64 or it will
-- line 518 ----------------------------------------
-- line 607 ----------------------------------------
          .                    .                   .           .              .           .           .          .          .               }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               /// This returns the `num_bases` `[Bp]`s in the `block_id`th block, starting
          .                    .                   .           .              .           .           .          .          .               /// from index `start_id`. 
          .                    .                   .           .              .           .           .          .          .               /// # Panics
          .                    .                   .           .              .           .           .          .          .               /// If `block_id` is not less than the number of sequence blocks, 
          .                    .                   .           .              .           .           .          .          .               /// or `start_id+num_bases` is more than the number of bases in the `block_id`th sequence block 
 11,079,250 ( 0.11%)           0           9,496,500 ( 0.98%)  1 ( 0.01%)     0          12 ( 0.00%)  1 ( 0.02%) .          .               pub fn return_bases(&self, block_id: usize, start_id: usize, num_bases: usize) -> Vec<Bp> {
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   let start_dec = self.block_u8_starts[block_id]+(start_id/BP_PER_U8);
          .                    .                   .           .              .           .           .          .          .                   let end_dec = self.block_u8_starts[block_id]+((start_id+num_bases-1)/BP_PER_U8)+1;
          .                    .                   .           .              .           .           .          .          .           
  9,496,500 ( 0.09%)   1,582,750 ( 0.09%)          0           1 ( 0.01%)    16 ( 0.00%)  0           1 ( 0.02%) .          .                   assert!(end_dec-start_dec <= self.block_lens[block_id]/BP_PER_U8, "Number of bases requested overflows the block");
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   let all_coded = &self.seq_blocks[start_dec..end_dec];
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   let all_bases: Vec<_> = all_coded.iter().map(|a| Self::code_to_bases(*a)).flatten().collect();
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           
  1,582,750 ( 0.02%)           .                   .           .              .           .           .          .          .                   let new_s = start_id % BP_PER_U8;
          .                    .                   .           .              .           .           .          .          .           
  6,331,000 ( 0.06%)   1,582,750 ( 0.09%)          0           1 ( 0.01%)     0           0           1 ( 0.02%) .          .                   let ret: Vec<Bp> = all_bases[new_s..(new_s+num_bases)].to_vec();
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   ret
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               //We exploit the ordering of the u64 versions of kmer to binary search
-- line 638 ----------------------------------------
-- line 893 ----------------------------------------
          .                    .                   .           .              .           .           .          .          .                       fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
          .                    .                   .           .              .           .           .          .          .                           formatter.write_str("struct Sequence")
          .                    .                   .           .              .           .           .          .          .                       }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                       fn visit_seq<V>(self, mut seq: V) -> Result<Sequence, V::Error>
          .                    .                   .           .              .           .           .          .          .                       where
          .                    .                   .           .              .           .           .          .          .                           V: SeqAccess<'de>,
          .                    .                   .           .              .           .           .          .          .                       {
          1 ( 0.00%)           0                   1 ( 0.00%)  .              .           .           .          .          .                           let seq_blocks: Vec<u8> = seq.next_element()?.ok_or_else(|| serde::de::Error::invalid_length(0, &self))?;
  2,218,329 ( 0.02%)     391,487 ( 0.02%)    521,926 ( 0.05%) 23 ( 0.33%) 2,047 ( 0.00%) 2,044 ( 0.03%)  8 ( 0.20%) 1 ( 0.00%) .           => /u/alimf/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.219/src/de/mod.rs:serde::de::SeqAccess::next_element (1x)
          6 ( 0.00%)           2 ( 0.00%)          3 ( 0.00%)  .              .           .           .          .          .                           let block_lens: Vec<usize> = seq.next_element()?.ok_or_else(|| serde::de::Error::invalid_length(1, &self))?;
      2,976 ( 0.00%)         635 ( 0.00%)        441 ( 0.00%) 17 ( 0.25%)    27 ( 0.00%) 17 ( 0.00%)  9 ( 0.22%) .          .           => /u/alimf/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.219/src/de/mod.rs:serde::de::SeqAccess::next_element (1x)
          3 ( 0.00%)           2 ( 0.00%)          1 ( 0.00%)  1 ( 0.01%)     0           0           1 ( 0.02%) .          .                           let positive_window_slices: Vec<(usize, usize, usize)> = seq.next_element()?.ok_or_else(|| serde::de::Error::invalid_length(2, &self))?;
          .                    .                   .           .              .           .           .          .          .                           Ok(Sequence::new_manual(seq_blocks, block_lens, &positive_window_slices))
          .                    .                   .           .              .           .           .          .          .                       }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                       fn visit_map<V>(self, mut map: V) -> Result<Sequence, V::Error>
          .                    .                   .           .              .           .           .          .          .                       where
          .                    .                   .           .              .           .           .          .          .                           V: MapAccess<'de>,
          .                    .                   .           .              .           .           .          .          .                       {
          .                    .                   .           .              .           .           .          .          .                           let mut seq_blocks: Option<Vec<u8>> = None;
-- line 911 ----------------------------------------
-- line 1044 ----------------------------------------
          .                    .                   .           .              .           .           .          .          .               /// Initializes a new Sequence from a single vector with base pair lengths 
          .                    .                   .           .              .           .           .          .          .               /// provides by `block_lens` 
          .                    .                   .           .              .           .           .          .          .               /// # Panics
          .                    .                   .           .              .           .           .          .          .               /// - If any element of `block_lens` is not divisible by `[BP_PER_U8]` 
          .                    .                   .           .              .           .           .          .          .               /// - If any element of `block_lens` is not greater than `[MAX_BASE]`
          .                    .                   .           .              .           .           .          .          .               /// - If the sum of `block_lens` is not equal to `[BP_PER_U8] * seq_blocks.len()`
          .                    .                   .           .              .           .           .          .          .               pub fn new_manual(seq_blocks: Vec<u8>, block_lens: Vec<usize>) -> NullSequence {
          .                    .                   .           .              .           .           .          .          .           
          1 ( 0.00%)           0                   1 ( 0.00%)  .              .           .           .          .          .                   let mut block_u8_starts: Vec<usize> = vec![0];
          .                    .                   .           .              .           .           .          .          .           
         85 ( 0.00%)           .                   .           .              .           .           .          .          .                   for i in 0..(block_lens.len()-1) {
        316 ( 0.00%)          79 ( 0.00%)          .           .              .           .           .          .          .                       if block_lens[i] >= MAX_BASE && block_lens[i] % BP_PER_U8 == 0{
        158 ( 0.00%)          79 ( 0.00%)          .           .              .           .           .          .          .                           block_u8_starts.push(block_u8_starts[i]+block_lens[i]/BP_PER_U8);
          .                    .                   .           .              .           .           .          .          .                       } else {
          .                    .                   .           .              .           .           .          .          .                           panic!("All blocks must be longer than your maximum possible motif size and divisible by {}!", BP_PER_U8);
          .                    .                   .           .              .           .           .          .          .                       }
          .                    .                   .           .              .           .           .          .          .                   }
          .                    .                   .           .              .           .           .          .          .           
          2 ( 0.00%)           0                   0           1 ( 0.01%)     0           0           1 ( 0.02%) .          .                   if block_lens.iter().map(|b| b/4).sum::<usize>() != seq_blocks.len() {
          .                    .                   .           .              .           .           .          .          .                       panic!("stated block lengths do not equal the length of your data!");
          .                    .                   .           .              .           .           .          .          .                   }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           
          1 ( 0.00%)           1 ( 0.00%)          .           .              .           .           .          .          .                   let max_len: usize = *block_lens.iter().max().unwrap();
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           
         28 ( 0.00%)           1 ( 0.00%)         25 ( 0.00%)  5 ( 0.07%)     0           1 ( 0.00%)  5 ( 0.12%) .          .                   let mut seq = NullSequence{
         86 ( 0.00%)          24 ( 0.00%)         21 ( 0.00%)  0              1 ( 0.00%)  9 ( 0.00%)  0          0          1 ( 0.00%)  => ???:__memcpy_avx_unaligned_erms (1x)
          .                    .                   .           .              .           .           .          .          .                       seq_blocks: seq_blocks,
          1 ( 0.00%)           1 ( 0.00%)          .           .              .           .           .          .          .                       block_u8_starts: block_u8_starts,
          .                    .                   .           .              .           .           .          .          .                       block_lens: block_lens,
          .                    .                   .           .              .           .           .          .          .                       max_len: max_len,
          .                    .                   .           .              .           .           .          .          .                       kmer_counts: core::array::from_fn(|a| HashMap::with_hasher(WyHash::with_seed(0))),
          .                    .                   .           .              .           .           .          .          .                       kmer_lists: core::array::from_fn(|a| Vec::new()),
          .                    .                   .           .              .           .           .          .          .                   };
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   seq.initialize_kmer_count();
          .                    .                   .           .              .           .           .          .          .                   seq
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               fn initialize_kmer_count(&mut self) {
          .                    .                   .           .              .           .           .          .          .           
         33 ( 0.00%)           0                   9 ( 0.00%)  2 ( 0.03%)     0           0           2 ( 0.05%) .          .                   let kmer_counts: [HashMap<u64, usize, WyHash>; MAX_BASE+1-MIN_BASE] = core::array::from_fn(|a| self.generate_kmer_counts(a+MIN_BASE));
          .                    .                   .           .              .           .           .          .          .                   self.kmer_counts = kmer_counts;
          .                    .                   .           .              .           .           .          .          .                   let kmer_lists: [Vec<u64>; MAX_BASE+1-MIN_BASE] = core::array::from_fn(|a| {
          .                    .                   .           .              .           .           .          .          .                       let mut kmers: Vec<u64> = self.kmer_counts[a].keys().map(|&b| b).collect();
          .                    .                   .           .              .           .           .          .          .                       kmers.sort_unstable();
          .                    .                   .           .              .           .           .          .          .                       kmers
          .                    .                   .           .              .           .           .          .          .                   });
          .                    .                   .           .              .           .           .          .          .                   self.kmer_lists = kmer_lists;
          .                    .                   .           .              .           .           .          .          .           
-- line 1094 ----------------------------------------
-- line 1102 ----------------------------------------
          .                    .                   .           .              .           .           .          .          .                   let mut unel: Vec<u64> = Vec::new();
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   let guess_capacity = 2_usize.pow(len as u32).min(self.block_lens.iter().sum::<usize>());
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   let hasher = WyHash::with_seed(0);
          .                    .                   .           .              .           .           .          .          .                   let mut lenmer_counts: HashMap<u64,usize, _> = HashMap::with_capacity_and_hasher(guess_capacity, hasher);
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   for i in 0..self.block_lens.len() {
        960 ( 0.00%)         240 ( 0.00%)        240 ( 0.00%)  0            237 ( 0.00%)  0           0          6 ( 0.01%) .                       if self.block_lens[i] >= len {
          .                    .                   .           .              .           .           .          .          .                           for j in 0..(self.block_lens[i]-len){
          .                    .                   .           .              .           .           .          .          .                               let kmer_u64 = Sequence::kmer_to_u64(&self.return_bases(i, j, len));
          .                    .                   .           .              .           .           .          .          .                               let rev_u64 = reverse_complement_u64_kmer(kmer_u64, len);
 23,060,476 ( 0.22%)           0          11,530,238 ( 1.19%)  .              .           .           .          .          .                               lenmer_counts.entry(kmer_u64).and_modify(|count| *count += 1).or_insert(1);
 11,531,221 ( 0.11%)           0          11,531,221 ( 1.19%)  .              .           .           .          .          .                               lenmer_counts.entry(rev_u64).and_modify(|count| *count += 1).or_insert(1);
          .                    .                   .           .              .           .           .          .          .                           }
          .                    .                   .           .              .           .           .          .          .                       }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   }
          .                    .                   .           .              .           .           .          .          .           
         12 ( 0.00%)           6 ( 0.00%)          6 ( 0.00%)  2 ( 0.03%)     0           2 ( 0.00%)  2 ( 0.05%) .          .                   lenmer_counts
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               //Regular reader functions
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               /// # Panics
-- line 1129 ----------------------------------------
-- line 1158 ----------------------------------------
          .                    .                   .           .              .           .           .          .          .               }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               pub fn num_sequence_blocks(&self) -> usize {
          .                    .                   .           .              .           .           .          .          .                   self.block_lens.len()
          .                    .                   .           .              .           .           .          .          .               }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               pub fn return_bases(&self, block_id: usize, start_id: usize, num_bases: usize) -> Vec<Bp> {
          .                    .                   .           .              .           .           .          .          .           
 48,707,664 ( 0.47%)  12,176,916 ( 0.66%)          0           0             58 ( 0.00%)  0           0          3 ( 0.01%) .                   let start_dec = self.block_u8_starts[block_id]+(start_id/BP_PER_U8);
 36,530,748 ( 0.35%)           0                   0           1 ( 0.01%)     0           0           1 ( 0.02%) .          .                   let end_dec = self.block_u8_starts[block_id]+((start_id+num_bases-1)/BP_PER_U8)+1;
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   let all_coded = &self.seq_blocks[start_dec..end_dec];
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   let all_bases: Vec<_> = all_coded.iter().map(|a| Sequence::code_to_bases(*a)).flatten().collect();
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           
 12,176,916 ( 0.12%)           .                   .           .              .           .           .          .          .                   let new_s = start_id % BP_PER_U8;
          .                    .                   .           .              .           .           .          .          .           
 24,353,832 ( 0.23%)           .                   .           .              .           .           .          .          .                   let ret: Vec<Bp> = all_bases[new_s..(new_s+num_bases)].to_vec();
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                   ret
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               pub fn kmer_count(&self, kmer: u64, len: usize) -> Option<usize> {
          .                    .                   .           .              .           .           .          .          .                   self.kmer_counts[len-MIN_BASE].get(&kmer).map(|a| *a) 
          .                    .                   .           .              .           .           .          .          .               }
-- line 1185 ----------------------------------------
-- line 1231 ----------------------------------------
          .                    .                   .           .              .           .           .          .          .                       fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
          .                    .                   .           .              .           .           .          .          .                           formatter.write_str("struct NullSequence")
          .                    .                   .           .              .           .           .          .          .                       }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                       fn visit_seq<V>(self, mut seq: V) -> Result<NullSequence, V::Error>
          .                    .                   .           .              .           .           .          .          .                       where
          .                    .                   .           .              .           .           .          .          .                           V: SeqAccess<'de>,
          .                    .                   .           .              .           .           .          .          .                       {
          1 ( 0.00%)           0                   1 ( 0.00%)  .              .           .           .          .          .                           let seq_blocks: Vec<u8> = seq.next_element()?.ok_or_else(|| serde::de::Error::invalid_length(0, &self))?;
 17,290,020 ( 0.17%)   3,051,196 ( 0.16%)  4,068,218 ( 0.42%)  4 ( 0.06%) 15,906 ( 0.03%) 15,899 ( 0.24%)  0          0          673 ( 0.03%)  => /u/alimf/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.219/src/de/mod.rs:serde::de::SeqAccess::next_element (1x)
          2 ( 0.00%)           0                   1 ( 0.00%)  .              .           .           .          .          .                           let block_lens: Vec<usize> = seq.next_element()?.ok_or_else(|| serde::de::Error::invalid_length(1, &self))?;
      2,267 ( 0.00%)         508 ( 0.00%)        343 ( 0.00%)  1 ( 0.01%)    17 ( 0.00%) 11 ( 0.00%)  .          .          .           => /u/alimf/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.219/src/de/mod.rs:serde::de::SeqAccess::next_element (1x)
          .                    .                   .           .              .           .           .          .          .           
          2 ( 0.00%)           .                   .           .              .           .           .          .          .                           if seq_blocks.len() == 0 && block_lens.len() == 0 { Ok(NullSequence::new_empty())} else{
          .                    .                   .           .              .           .           .          .          .                               Ok(NullSequence::new_manual(seq_blocks, block_lens))
          .                    .                   .           .              .           .           .          .          .                           }
          .                    .                   .           .              .           .           .          .          .                       }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .                       fn visit_map<V>(self, mut map: V) -> Result<NullSequence, V::Error>
          .                    .                   .           .              .           .           .          .          .                       where
          .                    .                   .           .              .           .           .          .          .                           V: MapAccess<'de>,
          .                    .                   .           .              .           .           .          .          .                       {
-- line 1250 ----------------------------------------
-- line 1280 ----------------------------------------
          .                    .                   .           .              .           .           .          .          .           }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           pub(crate) fn reverse_complement_u64_kmer(kmer: u64, len: usize) -> u64 {
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               let mut track_kmer = kmer;
          .                    .                   .           .              .           .           .          .          .               let mut rev_kmer: u64 = 0;
          .                    .                   .           .              .           .           .          .          .               for i in 0..len {
880,601,260 ( 8.44%)           0                   0           1 ( 0.01%)     0           0           1 ( 0.02%) .          .                   rev_kmer += ((track_kmer & 3) ^ 3) << (2*(len-1-i));
105,499,310 ( 1.01%)           .                   .           .              .           .           .          .          .                   track_kmer = track_kmer >> 2;
          .                    .                   .           .              .           .           .          .          .               }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .               rev_kmer
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           }
          .                    .                   .           .              .           .           .          .          .           
          .                    .                   .           .              .           .           .          .          .           pub(crate) fn plain_hamming_u64_kmer(kmer_a: u64, kmer_b: u64, len: usize) -> usize {
          .                    .                   .           .              .           .           .          .          .               let mut kmer_check = (kmer_a ^ kmer_b);
-- line 1297 ----------------------------------------

 68,830,841 ( 0.66%)  27,533,031 ( 1.48%)      9,148 ( 0.00%) 12 ( 0.17%)   223 ( 0.00%) 10 ( 0.00%) 12 ( 0.30%) 1 ( 0.00%) .           <counts for unidentified lines in src/sequence.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /u/alimf/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/wyhash2-0.2.1/src/lib.rs
--------------------------------------------------------------------------------
Ir                   Dr         Dw         I1mr       D1mr       D1mw       ILmr       DLmr DLmw 

-- line 26 ----------------------------------------
          .          .          .          .          .          .          .          .          .           
          .          .          .          .          .          .          .          .          .           #[inline]
          .          .          .          .          .          .          .          .          .           fn wyr8(data: &[u8; 8]) -> u64 {
          .          .          .          .          .          .          .          .          .               u64::from_ne_bytes(*data)
          .          .          .          .          .          .          .          .          .           }
          .          .          .          .          .          .          .          .          .           
          .          .          .          .          .          .          .          .          .           #[inline]
          .          .          .          .          .          .          .          .          .           fn wyr4(data: &[u8; 4]) -> u64 {
 28,171,599 ( 0.27%) 0          0          1 ( 0.01%) 0          0          1 ( 0.02%) .          .               u32::from_ne_bytes(*data) as u64
          .          .          .          .          .          .          .          .          .           }
          .          .          .          .          .          .          .          .          .           
          .          .          .          .          .          .          .          .          .           #[inline]
          .          .          .          .          .          .          .          .          .           fn wyr3(data: &[u8], k: usize) -> u64 {
          .          .          .          .          .          .          .          .          .               debug_assert!(k >> 1 <= data.len());
          .          .          .          .          .          .          .          .          .               unsafe {
          .          .          .          .          .          .          .          .          .                   ((*data.get_unchecked(0) as u64) << 16)
          .          .          .          .          .          .          .          .          .                       | ((*data.get_unchecked(k >> 1) as u64) << 8)
          .          .          .          .          .          .          .          .          .                       | (*data.get_unchecked(k - 1) as u64)
          .          .          .          .          .          .          .          .          .               }
          .          .          .          .          .          .          .          .          .           }
          .          .          .          .          .          .          .          .          .           
          .          .          .          .          .          .          .          .          .           #[inline]
          .          .          .          .          .          .          .          .          .           fn wymum(a: &mut u64, b: &mut u64) {
109,288,229 ( 1.05%) 0          0          2 ( 0.03%) 0          0          2 ( 0.05%) .          .               let r = u128::from(*a) * u128::from(*b);
          .          .          .          .          .          .          .          .          .           
          .          .          .          .          .          .          .          .          .               *a = r as u64;
          .          .          .          .          .          .          .          .          .               *b = (r >> 64) as u64;
          .          .          .          .          .          .          .          .          .           }
          .          .          .          .          .          .          .          .          .           
          .          .          .          .          .          .          .          .          .           #[inline]
          .          .          .          .          .          .          .          .          .           fn wymix(mut a: u64, mut b: u64) -> u64 {
          .          .          .          .          .          .          .          .          .               wymum(&mut a, &mut b);
          .          .          .          .          .          .          .          .          .           
 26,759,142 ( 0.26%) .          .          .          .          .          .          .          .               a ^ b
          .          .          .          .          .          .          .          .          .           }
          .          .          .          .          .          .          .          .          .           
          .          .          .          .          .          .          .          .          .           #[inline]
          .          .          .          .          .          .          .          .          .           pub fn _wyhash(bytes: &[u8], mut seed: u64) -> u64 {
          .          .          .          .          .          .          .          .          .               seed ^= P0;
          .          .          .          .          .          .          .          .          .           
          .          .          .          .          .          .          .          .          .               let a: u64;
          .          .          .          .          .          .          .          .          .               let b: u64;
          .          .          .          .          .          .          .          .          .           
          .          .          .          .          .          .          .          .          .               if likely!(bytes.len() <= 16) {
          .          .          .          .          .          .          .          .          .                   if likely!(bytes.len() <= 8) {
          .          .          .          .          .          .          .          .          .                       if likely!(bytes.len() >= 4) {
          .          .          .          .          .          .          .          .          .                           a = wyr4(as_array_4(&bytes[0..4]));
          .          .          .          .          .          .          .          .          .                           b = wyr4(as_array_4(&bytes[bytes.len() - 4..]));
112,686,396 ( 1.08%) .          .          .          .          .          .          .          .                           return wymix(a ^ P1, b ^ seed);
          .          .          .          .          .          .          .          .          .                       } else if likely!(!bytes.is_empty()) {
          .          .          .          .          .          .          .          .          .                           a = wyr3(&bytes[..], bytes.len());
          .          .          .          .          .          .          .          .          .                           b = 0;
          .          .          .          .          .          .          .          .          .                           return wymix(a ^ P1, b ^ seed);
          .          .          .          .          .          .          .          .          .                       } else {
          .          .          .          .          .          .          .          .          .                           a = 0;
          .          .          .          .          .          .          .          .          .                           b = 0;
          .          .          .          .          .          .          .          .          .                           return wymix(a ^ P1, b ^ seed);
-- line 82 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /u/alimf/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libdeflate-sys-1.24.0/libdeflate/lib/x86/../decompress_template.h
--------------------------------------------------------------------------------
Ir                 Dr               Dw               I1mr       D1mr            D1mw           ILmr       DLmr            DLmw           

-- line 41 ----------------------------------------
        .                .                .          .               .              .          .               .              .           #  define EXTRACT_VARBITS8(word, count)	((word) & BITMASK((u8)(count)))
        .                .                .          .               .              .          .               .              .           #endif
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           static ATTRIBUTES MAYBE_UNUSED enum libdeflate_result
        .                .                .          .               .              .          .               .              .           FUNCNAME(struct libdeflate_decompressor * restrict d,
        .                .                .          .               .              .          .               .              .           	 const void * restrict in, size_t in_nbytes,
        .                .                .          .               .              .          .               .              .           	 void * restrict out, size_t out_nbytes_avail,
        .                .                .          .               .              .          .               .              .           	 size_t *actual_in_nbytes_ret, size_t *actual_out_nbytes_ret)
       28 ( 0.00%)       0               18 ( 0.00%) 4 ( 0.06%)      0              0          2 ( 0.05%)      .              .           {
        .                .                .          .               .              .          .               .              .           	u8 *out_next = out;
        4 ( 0.00%)       0                2 ( 0.00%) .               .              .          .               .              .           	u8 * const out_end = out_next + out_nbytes_avail;
        8 ( 0.00%)       0                2 ( 0.00%) .               .              .          .               .              .           	u8 * const out_fastloop_end =
        .                .                .          .               .              .          .               .              .           		out_end - MIN(out_nbytes_avail, FASTLOOP_MAX_BYTES_WRITTEN);
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           	/* Input bitstream state; see deflate_decompress.c for documentation */
        2 ( 0.00%)       .                .          .               .              .          .               .              .           	const u8 *in_next = in;
        2 ( 0.00%)       .                .          .               .              .          .               .              .           	const u8 * const in_end = in_next + in_nbytes;
        8 ( 0.00%)       0                2 ( 0.00%) 1 ( 0.01%)      0              0          1 ( 0.02%)      .              .           	const u8 * const in_fastloop_end =
        .                .                .          .               .              .          .               .              .           		in_end - MIN(in_nbytes, FASTLOOP_MAX_BYTES_READ);
        2 ( 0.00%)       .                .          .               .              .          .               .              .           	bitbuf_t bitbuf = 0;
        .                .                .          .               .              .          .               .              .           	bitbuf_t saved_bitbuf;
        2 ( 0.00%)       .                .          .               .              .          .               .              .           	u32 bitsleft = 0;
        2 ( 0.00%)       0                2 ( 0.00%) .               .              .          .               .              .           	size_t overread_count = 0;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           	bool is_final_block;
        .                .                .          .               .              .          .               .              .           	unsigned block_type;
        .                .                .          .               .              .          .               .              .           	unsigned num_litlen_syms;
        .                .                .          .               .              .          .               .              .           	unsigned num_offset_syms;
        .                .                .          .               .              .          .               .              .           	bitbuf_t litlen_tablemask;
        .                .                .          .               .              .          .               .              .           	u32 entry;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           next_block:
        .                .                .          .               .              .          .               .              .           	/* Starting to read the next block */
        .                .                .          .               .              .          .               .              .           	;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           	STATIC_ASSERT(CAN_CONSUME(1 + 2 + 5 + 5 + 4 + 3));
      168 ( 0.00%)      12 ( 0.00%)      12 ( 0.00%) 1 ( 0.01%)      1 ( 0.00%)     0          1 ( 0.02%)      .              .           	REFILL_BITS();
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           	/* BFINAL: 1 bit */
        .                .                .          .               .              .          .               .              .           	is_final_block = bitbuf & BITMASK(1);
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           	/* BTYPE: 2 bits */
       36 ( 0.00%)      12 ( 0.00%)       .          .               .              .          .               .              .           	block_type = (bitbuf >> 1) & BITMASK(2);
        .                .                .          .               .              .          .               .              .           
       24 ( 0.00%)       .                .          .               .              .          .               .              .           	if (block_type == DEFLATE_BLOCKTYPE_DYNAMIC_HUFFMAN) {
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		/* Dynamic Huffman block */
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		/* The order in which precode lengths are stored */
        .                .                .          .               .              .          .               .              .           		static const u8 deflate_precode_lens_permutation[DEFLATE_NUM_PRECODE_SYMS] = {
        .                .                .          .               .              .          .               .              .           			16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
        .                .                .          .               .              .          .               .              .           		};
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		unsigned num_explicit_precode_lens;
        .                .                .          .               .              .          .               .              .           		unsigned i;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		/* Read the codeword length counts. */
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		STATIC_ASSERT(DEFLATE_NUM_LITLEN_SYMS == 257 + BITMASK(5));
       72 ( 0.00%)      12 ( 0.00%)      12 ( 0.00%) 1 ( 0.01%)      0              0          1 ( 0.02%)      .              .           		num_litlen_syms = 257 + ((bitbuf >> 3) & BITMASK(5));
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		STATIC_ASSERT(DEFLATE_NUM_OFFSET_SYMS == 1 + BITMASK(5));
       60 ( 0.00%)       0               12 ( 0.00%) .               .              .          .               .              .           		num_offset_syms = 1 + ((bitbuf >> 8) & BITMASK(5));
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		STATIC_ASSERT(DEFLATE_NUM_PRECODE_SYMS == 4 + BITMASK(4));
       48 ( 0.00%)       .                .          .               .              .          .               .              .           		num_explicit_precode_lens = 4 + ((bitbuf >> 13) & BITMASK(4));
        .                .                .          .               .              .          .               .              .           
       12 ( 0.00%)       0               12 ( 0.00%) 1 ( 0.01%)      0             10 ( 0.00%) 1 ( 0.02%)      .              .           		d->static_codes_loaded = false;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		/*
        .                .                .          .               .              .          .               .              .           		 * Read the precode codeword lengths.
        .                .                .          .               .              .          .               .              .           		 *
        .                .                .          .               .              .          .               .              .           		 * A 64-bit bitbuffer is just one bit too small to hold the
        .                .                .          .               .              .          .               .              .           		 * maximum number of precode lens, so to minimize branches we
        .                .                .          .               .              .          .               .              .           		 * merge one len with the previous fields.
        .                .                .          .               .              .          .               .              .           		 */
        .                .                .          .               .              .          .               .              .           		STATIC_ASSERT(DEFLATE_MAX_PRE_CODEWORD_LEN == (1 << 3) - 1);
        .                .                .          .               .              .          .               .              .           		if (CAN_CONSUME(3 * (DEFLATE_NUM_PRECODE_SYMS - 1))) {
        .                .                .          .               .              .          .               .              .           			d->u.precode_lens[deflate_precode_lens_permutation[0]] =
       48 ( 0.00%)       0               12 ( 0.00%) 0               0              2 ( 0.00%) 0               0              2 ( 0.00%)  				(bitbuf >> 17) & BITMASK(3);
       24 ( 0.00%)       .                .          .               .              .          .               .              .           			bitbuf >>= 20;
       12 ( 0.00%)       .                .          .               .              .          .               .              .           			bitsleft -= 20;
      156 ( 0.00%)      12 ( 0.00%)       0          1 ( 0.01%)      1 ( 0.00%)     0          1 ( 0.02%)      1 ( 0.00%)     .           			REFILL_BITS();
       60 ( 0.00%)       .                .          .               .              .          .               .              .           			i = 1;
        .                .                .          .               .              .          .               .              .           			do {
      185 ( 0.00%)     185 ( 0.00%)       0          0              11 ( 0.00%)     .          .               .              .           				d->u.precode_lens[deflate_precode_lens_permutation[i]] =
      555 ( 0.00%)       0              185 ( 0.00%) .               .              .          .               .              .           					bitbuf & BITMASK(3);
      185 ( 0.00%)       .                .          .               .              .          .               .              .           				bitbuf >>= 3;
       48 ( 0.00%)       .                .          .               .              .          .               .              .           				bitsleft -= 3;
      555 ( 0.00%)       0                0          1 ( 0.01%)      0              0          1 ( 0.02%)      .              .           			} while (++i < num_explicit_precode_lens);
        .                .                .          .               .              .          .               .              .           		} else {
        .                .                .          .               .              .          .               .              .           			bitbuf >>= 17;
        .                .                .          .               .              .          .               .              .           			bitsleft -= 17;
        .                .                .          .               .              .          .               .              .           			i = 0;
        .                .                .          .               .              .          .               .              .           			do {
        .                .                .          .               .              .          .               .              .           				if ((u8)bitsleft < 3)
        .                .                .          .               .              .          .               .              .           					REFILL_BITS();
        .                .                .          .               .              .          .               .              .           				d->u.precode_lens[deflate_precode_lens_permutation[i]] =
        .                .                .          .               .              .          .               .              .           					bitbuf & BITMASK(3);
        .                .                .          .               .              .          .               .              .           				bitbuf >>= 3;
        .                .                .          .               .              .          .               .              .           				bitsleft -= 3;
        .                .                .          .               .              .          .               .              .           			} while (++i < num_explicit_precode_lens);
        .                .                .          .               .              .          .               .              .           		}
      117 ( 0.00%)       0                0          2 ( 0.03%)      0              0          2 ( 0.05%)      .              .           		for (; i < DEFLATE_NUM_PRECODE_SYMS; i++)
       86 ( 0.00%)      31 ( 0.00%)      31 ( 0.00%) .               .              .          .               .              .           			d->u.precode_lens[deflate_precode_lens_permutation[i]] = 0;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		/* Build the decode table for the precode. */
       60 ( 0.00%)      36 ( 0.00%)       0          1 ( 0.01%)      0              0          1 ( 0.02%)      .              .           		SAFETY_CHECK(build_precode_decode_table(d));
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		/* Decode the litlen and offset codeword lengths. */
       12 ( 0.00%)       .                .          .               .              .          .               .              .           		i = 0;
        .                .                .          .               .              .          .               .              .           		do {
        .                .                .          .               .              .          .               .              .           			unsigned presym;
        .                .                .          .               .              .          .               .              .           			u8 rep_val;
        .                .                .          .               .              .          .               .              .           			unsigned rep_count;
        .                .                .          .               .              .          .               .              .           
    4,888 ( 0.00%)       0                0          1 ( 0.01%)      0              0          1 ( 0.02%)      .              .           			if ((u8)bitsleft < DEFLATE_MAX_PRE_CODEWORD_LEN + 7)
    1,968 ( 0.00%)     158 ( 0.00%)       0          3 ( 0.04%)     10 ( 0.00%)     0          3 ( 0.07%)     10 ( 0.02%)     .           				REFILL_BITS();
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           			/*
        .                .                .          .               .              .          .               .              .           			 * The code below assumes that the precode decode table
        .                .                .          .               .              .          .               .              .           			 * doesn't have any subtables.
        .                .                .          .               .              .          .               .              .           			 */
        .                .                .          .               .              .          .               .              .           			STATIC_ASSERT(PRECODE_TABLEBITS == DEFLATE_MAX_PRE_CODEWORD_LEN);
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           			/* Decode the next precode symbol. */
    2,444 ( 0.00%)   2,444 ( 0.00%)       .          .               .              .          .               .              .           			entry = d->u.l.precode_decode_table[
    4,888 ( 0.00%)       .                .          .               .              .          .               .              .           				bitbuf & BITMASK(DEFLATE_MAX_PRE_CODEWORD_LEN)];
    2,444 ( 0.00%)       .                .          .               .              .          .               .              .           			bitbuf >>= (u8)entry;
    2,444 ( 0.00%)       .                .          .               .              .          .               .              .           			bitsleft -= entry; /* optimization: subtract full entry */
    4,888 ( 0.00%)       0                0          1 ( 0.01%)      0              0          1 ( 0.02%)      .              .           			presym = entry >> 16;
        .                .                .          .               .              .          .               .              .           
    4,888 ( 0.00%)       .                .          .               .              .          .               .              .           			if (presym < 16) {
        .                .                .          .               .              .          .               .              .           				/* Explicit codeword length */
    6,402 ( 0.00%)       0            2,134 ( 0.00%) 0               0              5 ( 0.00%) 0               0              5 ( 0.00%)  				d->u.l.lens[i++] = presym;
    2,134 ( 0.00%)       .                .          .               .              .          .               .              .           				continue;
        .                .                .          .               .              .          .               .              .           			}
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           			/* Run-length encoded codeword lengths */
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           			/*
        .                .                .          .               .              .          .               .              .           			 * Note: we don't need to immediately verify that the
        .                .                .          .               .              .          .               .              .           			 * repeat count doesn't overflow the number of elements,
        .                .                .          .               .              .          .               .              .           			 * since we've sized the lens array to have enough extra
-- line 184 ----------------------------------------
-- line 192 ----------------------------------------
        .                .                .          .               .              .          .               .              .           			 *
        .                .                .          .               .              .          .               .              .           			 * It is not just because of the numerical order that
        .                .                .          .               .              .          .               .              .           			 * our checks go in the order 'presym < 16', 'presym ==
        .                .                .          .               .              .          .               .              .           			 * 16', and 'presym == 17'.  For typical data this is
        .                .                .          .               .              .          .               .              .           			 * ordered from most frequent to least frequent case.
        .                .                .          .               .              .          .               .              .           			 */
        .                .                .          .               .              .          .               .              .           			STATIC_ASSERT(DEFLATE_MAX_LENS_OVERRUN == 138 - 1);
        .                .                .          .               .              .          .               .              .           
      620 ( 0.00%)       .                .          .               .              .          .               .              .           			if (presym == 16) {
        .                .                .          .               .              .          .               .              .           				/* Repeat the previous length 3 - 6 times. */
      586 ( 0.00%)       .                .          .               .              .          .               .              .           				SAFETY_CHECK(i != 0);
      586 ( 0.00%)     293 ( 0.00%)       .          .               .              .          .               .              .           				rep_val = d->u.l.lens[i - 1];
        .                .                .          .               .              .          .               .              .           				STATIC_ASSERT(3 + BITMASK(2) == 6);
      603 ( 0.00%)       .                .          .               .              .          .               .              .           				rep_count = 3 + (bitbuf & BITMASK(2));
      293 ( 0.00%)       .                .          .               .              .          .               .              .           				bitbuf >>= 2;
      293 ( 0.00%)       0                0          1 ( 0.01%)      0              0          1 ( 0.02%)      .              .           				bitsleft -= 2;
      879 ( 0.00%)       0              293 ( 0.00%) .               .              .          .               .              .           				d->u.l.lens[i + 0] = rep_val;
      586 ( 0.00%)       0              293 ( 0.00%) 0               0              3 ( 0.00%) 0               0              3 ( 0.00%)  				d->u.l.lens[i + 1] = rep_val;
      586 ( 0.00%)       0              293 ( 0.00%) .               .              .          .               .              .           				d->u.l.lens[i + 2] = rep_val;
      586 ( 0.00%)       0              293 ( 0.00%) .               .              .          .               .              .           				d->u.l.lens[i + 3] = rep_val;
      586 ( 0.00%)       0              293 ( 0.00%) .               .              .          .               .              .           				d->u.l.lens[i + 4] = rep_val;
      586 ( 0.00%)       0              293 ( 0.00%) .               .              .          .               .              .           				d->u.l.lens[i + 5] = rep_val;
      586 ( 0.00%)       .                .          .               .              .          .               .              .           				i += rep_count;
       34 ( 0.00%)       .                .          .               .              .          .               .              .           			} else if (presym == 17) {
        .                .                .          .               .              .          .               .              .           				/* Repeat zero 3 - 10 times. */
        .                .                .          .               .              .          .               .              .           				STATIC_ASSERT(3 + BITMASK(3) == 10);
       17 ( 0.00%)       .                .          .               .              .          .               .              .           				rep_count = 3 + (bitbuf & BITMASK(3));
       17 ( 0.00%)       .                .          .               .              .          .               .              .           				bitbuf >>= 3;
       17 ( 0.00%)       .                .          .               .              .          .               .              .           				bitsleft -= 3;
       34 ( 0.00%)       0               17 ( 0.00%) .               .              .          .               .              .           				d->u.l.lens[i + 0] = 0;
        .                .                .          .               .              .          .               .              .           				d->u.l.lens[i + 1] = 0;
        .                .                .          .               .              .          .               .              .           				d->u.l.lens[i + 2] = 0;
        .                .                .          .               .              .          .               .              .           				d->u.l.lens[i + 3] = 0;
        .                .                .          .               .              .          .               .              .           				d->u.l.lens[i + 4] = 0;
        .                .                .          .               .              .          .               .              .           				d->u.l.lens[i + 5] = 0;
        .                .                .          .               .              .          .               .              .           				d->u.l.lens[i + 6] = 0;
        .                .                .          .               .              .          .               .              .           				d->u.l.lens[i + 7] = 0;
       34 ( 0.00%)       0               17 ( 0.00%) .               .              .          .               .              .           				d->u.l.lens[i + 8] = 0;
       34 ( 0.00%)       0               17 ( 0.00%) .               .              .          .               .              .           				d->u.l.lens[i + 9] = 0;
       17 ( 0.00%)       .                .          .               .              .          .               .              .           				i += rep_count;
        .                .                .          .               .              .          .               .              .           			} else {
        .                .                .          .               .              .          .               .              .           				/* Repeat zero 11 - 138 times. */
        .                .                .          .               .              .          .               .              .           				STATIC_ASSERT(11 + BITMASK(7) == 138);
        .                .                .          .               .              .          .               .              .           				rep_count = 11 + (bitbuf & BITMASK(7));
        .                .                .          .               .              .          .               .              .           				bitbuf >>= 7;
        .                .                .          .               .              .          .               .              .           				bitsleft -= 7;
       12 ( 0.00%)       .                .          .               .              .          .               .              .           				memset(&d->u.l.lens[i], 0,
        .                .                .          .               .              .          .               .              .           				       rep_count * sizeof(d->u.l.lens[i]));
        .                .                .          .               .              .          .               .              .           				i += rep_count;
        .                .                .          .               .              .          .               .              .           			}
    4,924 ( 0.00%)      24 ( 0.00%)       .          .               .              .          .               .              .           		} while (i < num_litlen_syms + num_offset_syms);
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		/* Unnecessary, but check this for consistency with zlib. */
       12 ( 0.00%)       0                0          2 ( 0.03%)      0              0          1 ( 0.02%)      .              .           		SAFETY_CHECK(i == num_litlen_syms + num_offset_syms);
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           	} else if (block_type == DEFLATE_BLOCKTYPE_UNCOMPRESSED) {
        .                .                .          .               .              .          .               .              .           		u16 len, nlen;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		/*
        .                .                .          .               .              .          .               .              .           		 * Uncompressed block: copy 'len' bytes literally from the input
        .                .                .          .               .              .          .               .              .           		 * buffer to the output buffer.
        .                .                .          .               .              .          .               .              .           		 */
-- line 253 ----------------------------------------
-- line 323 ----------------------------------------
        .                .                .          .               .              .          .               .              .           			d->u.l.lens[i] = 5;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		num_litlen_syms = 288;
        .                .                .          .               .              .          .               .              .           		num_offset_syms = 32;
        .                .                .          .               .              .          .               .              .           	}
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           	/* Decompressing a Huffman block (either dynamic or static) */
        .                .                .          .               .              .          .               .              .           
       48 ( 0.00%)      24 ( 0.00%)       .          .               .              .          .               .              .           	SAFETY_CHECK(build_offset_decode_table(d, num_litlen_syms, num_offset_syms));
       60 ( 0.00%)      36 ( 0.00%)       .          .               .              .          .               .              .           	SAFETY_CHECK(build_litlen_decode_table(d, num_litlen_syms, num_offset_syms));
        .                .                .          .               .              .          .               .              .           have_decode_tables:
       60 ( 0.00%)      12 ( 0.00%)      12 ( 0.00%) 1 ( 0.01%)      0              0          1 ( 0.02%)      .              .           	litlen_tablemask = BITMASK(d->litlen_tablebits);
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           	/*
        .                .                .          .               .              .          .               .              .           	 * This is the "fastloop" for decoding literals and matches.  It does
        .                .                .          .               .              .          .               .              .           	 * bounds checks on in_next and out_next in the loop conditions so that
        .                .                .          .               .              .          .               .              .           	 * additional bounds checks aren't needed inside the loop body.
        .                .                .          .               .              .          .               .              .           	 *
        .                .                .          .               .              .          .               .              .           	 * To reduce latency, the bitbuffer is refilled and the next litlen
        .                .                .          .               .              .          .               .              .           	 * decode table entry is preloaded before each loop iteration.
        .                .                .          .               .              .          .               .              .           	 */
       48 ( 0.00%)      24 ( 0.00%)       .          .               .              .          .               .              .           	if (in_next >= in_fastloop_end || out_next >= out_fastloop_end)
        .                .                .          .               .              .          .               .              .           		goto generic_loop;
       96 ( 0.00%)      12 ( 0.00%)       .          .               .              .          .               .              .           	REFILL_BITS_IN_FASTLOOP();
       48 ( 0.00%)      12 ( 0.00%)       .          .               .              .          .               .              .           	entry = d->u.litlen_decode_table[bitbuf & litlen_tablemask];
        .                .                .          .               .              .          .               .              .           	do {
        .                .                .          .               .              .          .               .              .           		u32 length, offset, lit;
        .                .                .          .               .              .          .               .              .           		const u8 *src;
        .                .                .          .               .              .          .               .              .           		u8 *dst;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		/*
        .                .                .          .               .              .          .               .              .           		 * Consume the bits for the litlen decode table entry.  Save the
        .                .                .          .               .              .          .               .              .           		 * original bitbuf for later, in case the extra match length
        .                .                .          .               .              .          .               .              .           		 * bits need to be extracted from it.
        .                .                .          .               .              .          .               .              .           		 */
        .                .                .          .               .              .          .               .              .           		saved_bitbuf = bitbuf;
  424,734 ( 0.00%)       .                .          .               .              .          .               .              .           		bitbuf >>= (u8)entry;
  849,468 ( 0.01%)       .                .          .               .              .          .               .              .           		bitsleft -= entry; /* optimization: subtract full entry */
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		/*
        .                .                .          .               .              .          .               .              .           		 * Begin by checking for a "fast" literal, i.e. a literal that
        .                .                .          .               .              .          .               .              .           		 * doesn't need a subtable.
        .                .                .          .               .              .          .               .              .           		 */
  849,468 ( 0.01%)       .                .          .               .              .          .               .              .           		if (entry & HUFFDEC_LITERAL) {
        .                .                .          .               .              .          .               .              .           			/*
        .                .                .          .               .              .          .               .              .           			 * On 64-bit platforms, we decode up to 2 extra fast
        .                .                .          .               .              .          .               .              .           			 * literals in addition to the primary item, as this
        .                .                .          .               .              .          .               .              .           			 * increases performance and still leaves enough bits
        .                .                .          .               .              .          .               .              .           			 * remaining for what follows.  We could actually do 3,
        .                .                .          .               .              .          .               .              .           			 * assuming LITLEN_TABLEBITS=11, but that actually
        .                .                .          .               .              .          .               .              .           			 * decreases performance slightly (perhaps by messing
        .                .                .          .               .              .          .               .              .           			 * with the branch prediction of the conditional refill
-- line 374 ----------------------------------------
-- line 382 ----------------------------------------
        .                .                .          .               .              .          .               .              .           			    CAN_CONSUME_AND_THEN_PRELOAD(2 * LITLEN_TABLEBITS +
        .                .                .          .               .              .          .               .              .           							 LENGTH_MAXBITS,
        .                .                .          .               .              .          .               .              .           							 OFFSET_TABLEBITS) &&
        .                .                .          .               .              .          .               .              .           			    /* enough bits for 2 fast literals + slow literal + litlen preload? */
        .                .                .          .               .              .          .               .              .           			    CAN_CONSUME_AND_THEN_PRELOAD(2 * LITLEN_TABLEBITS +
        .                .                .          .               .              .          .               .              .           							 DEFLATE_MAX_LITLEN_CODEWORD_LEN,
        .                .                .          .               .              .          .               .              .           							 LITLEN_TABLEBITS)) {
        .                .                .          .               .              .          .               .              .           				/* 1st extra fast literal */
  835,150 ( 0.01%)       0                0          2 ( 0.03%)      0              0          1 ( 0.02%)      .              .           				lit = entry >> 16;
1,252,725 ( 0.01%) 417,575 ( 0.02%)       0          0               6 ( 0.00%)     .          .               .              .           				entry = d->u.litlen_decode_table[bitbuf & litlen_tablemask];
    5,591 ( 0.00%)       .                .          .               .              .          .               .              .           				saved_bitbuf = bitbuf;
  423,166 ( 0.00%)       .                .          .               .              .          .               .              .           				bitbuf >>= (u8)entry;
  417,575 ( 0.00%)       .                .          .               .              .          .               .              .           				bitsleft -= entry;
  428,757 ( 0.00%)       0          417,575 ( 0.04%) 1 ( 0.01%)      0          5,728 ( 0.08%) 1 ( 0.02%)      0          5,728 ( 0.25%)  				*out_next++ = lit;
  835,150 ( 0.01%)       .                .          .               .              .          .               .              .           				if (entry & HUFFDEC_LITERAL) {
        .                .                .          .               .              .          .               .              .           					/* 2nd extra fast literal */
  823,968 ( 0.01%)       .                .          .               .              .          .               .              .           					lit = entry >> 16;
1,235,952 ( 0.01%) 411,984 ( 0.02%)       0          2 ( 0.03%)      4 ( 0.00%)     0          1 ( 0.02%)      .              .           					entry = d->u.litlen_decode_table[bitbuf & litlen_tablemask];
        .                .                .          .               .              .          .               .              .           					saved_bitbuf = bitbuf;
  411,984 ( 0.00%)       .                .          .               .              .          .               .              .           					bitbuf >>= (u8)entry;
  411,984 ( 0.00%)       .                .          .               .              .          .               .              .           					bitsleft -= entry;
  823,968 ( 0.01%)       0          411,984 ( 0.04%) 0               0          5,774 ( 0.09%) 0               0          5,774 ( 0.25%)  					*out_next++ = lit;
  823,968 ( 0.01%)       .                .          .               .              .          .               .              .           					if (entry & HUFFDEC_LITERAL) {
        .                .                .          .               .              .          .               .              .           						/*
        .                .                .          .               .              .          .               .              .           						 * Another fast literal, but
        .                .                .          .               .              .          .               .              .           						 * this one is in lieu of the
        .                .                .          .               .              .          .               .              .           						 * primary item, so it doesn't
        .                .                .          .               .              .          .               .              .           						 * count as one of the extras.
        .                .                .          .               .              .          .               .              .           						 */
  819,002 ( 0.01%)       .                .          .               .              .          .               .              .           						lit = entry >> 16;
1,228,503 ( 0.01%) 409,501 ( 0.02%)       0          0               7 ( 0.00%)     .          .               .              .           						entry = d->u.litlen_decode_table[bitbuf & litlen_tablemask];
3,685,509 ( 0.04%) 409,501 ( 0.02%)       0          0          19,069 ( 0.04%)     0          0          19,069 (46.81%)     .           						REFILL_BITS_IN_FASTLOOP();
  819,002 ( 0.01%)       0          409,501 ( 0.04%) 1 ( 0.01%)      0          5,722 ( 0.08%) 1 ( 0.02%)      0          5,722 ( 0.25%)  						*out_next++ = lit;
  409,501 ( 0.00%)       .                .          .               .              .          .               .              .           						continue;
        .                .                .          .               .              .          .               .              .           					}
        .                .                .          .               .              .          .               .              .           				}
        .                .                .          .               .              .          .               .              .           			} else {
        .                .                .          .               .              .          .               .              .           				/*
        .                .                .          .               .              .          .               .              .           				 * Decode a literal.  While doing so, preload
        .                .                .          .               .              .          .               .              .           				 * the next litlen decode table entry and refill
        .                .                .          .               .              .          .               .              .           				 * the bitbuffer.  To reduce latency, we've
        .                .                .          .               .              .          .               .              .           				 * arranged for there to be enough "preloadable"
-- line 423 ----------------------------------------
-- line 434 ----------------------------------------
        .                .                .          .               .              .          .               .              .           			}
        .                .                .          .               .              .          .               .              .           		}
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		/*
        .                .                .          .               .              .          .               .              .           		 * It's not a literal entry, so it can be a length entry, a
        .                .                .          .               .              .          .               .              .           		 * subtable pointer entry, or an end-of-block entry.  Detect the
        .                .                .          .               .              .          .               .              .           		 * two unlikely cases by testing the HUFFDEC_EXCEPTIONAL flag.
        .                .                .          .               .              .          .               .              .           		 */
   30,466 ( 0.00%)       .                .          .               .              .          .               .              .           		if (unlikely(entry & HUFFDEC_EXCEPTIONAL)) {
        .                .                .          .               .              .          .               .              .           			/* Subtable pointer or end-of-block entry */
        .                .                .          .               .              .          .               .              .           
    2,384 ( 0.00%)       .                .          .               .              .          .               .              .           			if (unlikely(entry & HUFFDEC_END_OF_BLOCK))
        .                .                .          .               .              .          .               .              .           				goto block_done;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           			/*
        .                .                .          .               .              .          .               .              .           			 * A subtable is required.  Load and consume the
        .                .                .          .               .              .          .               .              .           			 * subtable entry.  The subtable entry can be of any
        .                .                .          .               .              .          .               .              .           			 * type: literal, length, or end-of-block.
        .                .                .          .               .              .          .               .              .           			 */
    3,570 ( 0.00%)   1,190 ( 0.00%)       0          0              13 ( 0.00%)     .          .               .              .           			entry = d->u.litlen_decode_table[(entry >> 16) +
    3,570 ( 0.00%)       .                .          .               .              .          .               .              .           				EXTRACT_VARBITS(bitbuf, (entry >> 8) & 0x3F)];
        .                .                .          .               .              .          .               .              .           			saved_bitbuf = bitbuf;
    2,726 ( 0.00%)       .                .          .               .              .          .               .              .           			bitbuf >>= (u8)entry;
    1,190 ( 0.00%)       .                .          .               .              .          .               .              .           			bitsleft -= entry;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           			/*
        .                .                .          .               .              .          .               .              .           			 * 32-bit platforms that use the byte-at-a-time refill
        .                .                .          .               .              .          .               .              .           			 * method have to do a refill here for there to always
        .                .                .          .               .              .          .               .              .           			 * be enough bits to decode a literal that requires a
        .                .                .          .               .              .          .               .              .           			 * subtable, then preload the next litlen decode table
        .                .                .          .               .              .          .               .              .           			 * entry; or to decode a match length that requires a
        .                .                .          .               .              .          .               .              .           			 * subtable, then preload the offset decode table entry.
        .                .                .          .               .              .          .               .              .           			 */
        .                .                .          .               .              .          .               .              .           			if (!CAN_CONSUME_AND_THEN_PRELOAD(DEFLATE_MAX_LITLEN_CODEWORD_LEN,
        .                .                .          .               .              .          .               .              .           							  LITLEN_TABLEBITS) ||
        .                .                .          .               .              .          .               .              .           			    !CAN_CONSUME_AND_THEN_PRELOAD(LENGTH_MAXBITS,
        .                .                .          .               .              .          .               .              .           							  OFFSET_TABLEBITS))
        .                .                .          .               .              .          .               .              .           				REFILL_BITS_IN_FASTLOOP();
    2,380 ( 0.00%)       .                .          .               .              .          .               .              .           			if (entry & HUFFDEC_LITERAL) {
        .                .                .          .               .              .          .               .              .           				/* Decode a literal that required a subtable. */
    1,340 ( 0.00%)       .                .          .               .              .          .               .              .           				lit = entry >> 16;
    2,010 ( 0.00%)     670 ( 0.00%)       0          1 ( 0.01%)      0              0          1 ( 0.02%)      .              .           				entry = d->u.litlen_decode_table[bitbuf & litlen_tablemask];
    6,030 ( 0.00%)     670 ( 0.00%)       0          0              27 ( 0.00%)     0          0              27 ( 0.07%)     .           				REFILL_BITS_IN_FASTLOOP();
    1,340 ( 0.00%)       0              670 ( 0.00%) 0               0              8 ( 0.00%) 0               0              8 ( 0.00%)  				*out_next++ = lit;
      670 ( 0.00%)       0                0          1 ( 0.01%)      0              0          1 ( 0.02%)      .              .           				continue;
        .                .                .          .               .              .          .               .              .           			}
    1,040 ( 0.00%)       .                .          .               .              .          .               .              .           			if (unlikely(entry & HUFFDEC_END_OF_BLOCK))
        .                .                .          .               .              .          .               .              .           				goto block_done;
        .                .                .          .               .              .          .               .              .           			/* Else, it's a length that required a subtable. */
        .                .                .          .               .              .          .               .              .           		}
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		/*
        .                .                .          .               .              .          .               .              .           		 * Decode the match length: the length base value associated
        .                .                .          .               .              .          .               .              .           		 * with the litlen symbol (which we extract from the decode
        .                .                .          .               .              .          .               .              .           		 * table entry), plus the extra length bits.  We don't need to
        .                .                .          .               .              .          .               .              .           		 * consume the extra length bits here, as they were included in
        .                .                .          .               .              .          .               .              .           		 * the bits consumed by the entry earlier.  We also don't need
        .                .                .          .               .              .          .               .              .           		 * to check for too-long matches here, as this is inside the
        .                .                .          .               .              .          .               .              .           		 * fastloop where it's already been verified that the output
        .                .                .          .               .              .          .               .              .           		 * buffer has enough space remaining to copy a max-length match.
        .                .                .          .               .              .          .               .              .           		 */
   29,106 ( 0.00%)       .                .          .               .              .          .               .              .           		length = entry >> 16;
   43,659 ( 0.00%)       .                .          .               .              .          .               .              .           		length += EXTRACT_VARBITS8(saved_bitbuf, entry) >> (u8)(entry >> 8);
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		/*
        .                .                .          .               .              .          .               .              .           		 * Decode the match offset.  There are enough "preloadable" bits
        .                .                .          .               .              .          .               .              .           		 * remaining to preload the offset decode table entry, but a
        .                .                .          .               .              .          .               .              .           		 * refill might be needed before consuming it.
        .                .                .          .               .              .          .               .              .           		 */
        .                .                .          .               .              .          .               .              .           		STATIC_ASSERT(CAN_CONSUME_AND_THEN_PRELOAD(LENGTH_MAXFASTBITS,
        .                .                .          .               .              .          .               .              .           							   OFFSET_TABLEBITS));
   29,106 ( 0.00%)  14,553 ( 0.00%)       0          0             661 ( 0.00%)     .          .               .              .           		entry = d->offset_decode_table[bitbuf & BITMASK(OFFSET_TABLEBITS)];
        .                .                .          .               .              .          .               .              .           		if (CAN_CONSUME_AND_THEN_PRELOAD(OFFSET_MAXBITS,
        .                .                .          .               .              .          .               .              .           						 LITLEN_TABLEBITS)) {
        .                .                .          .               .              .          .               .              .           			/*
        .                .                .          .               .              .          .               .              .           			 * Decoding a match offset on a 64-bit platform.  We may
        .                .                .          .               .              .          .               .              .           			 * need to refill once, but then we can decode the whole
        .                .                .          .               .              .          .               .              .           			 * offset and preload the next litlen table entry.
        .                .                .          .               .              .          .               .              .           			 */
   29,106 ( 0.00%)       .                .          .               .              .          .               .              .           			if (unlikely(entry & HUFFDEC_EXCEPTIONAL)) {
        .                .                .          .               .              .          .               .              .           				/* Offset codeword requires a subtable */
      186 ( 0.00%)       0                0          1 ( 0.01%)      0              0          1 ( 0.02%)      .              .           				if (unlikely((u8)bitsleft < OFFSET_MAXBITS +
        .                .                .          .               .              .          .               .              .           					     LITLEN_TABLEBITS - PRELOAD_SLACK))
       80 ( 0.00%)       8 ( 0.00%)       0          1 ( 0.01%)      0              0          1 ( 0.02%)      .              .           					REFILL_BITS_IN_FASTLOOP();
       93 ( 0.00%)       .                .          .               .              .          .               .              .           				bitbuf >>= OFFSET_TABLEBITS;
       93 ( 0.00%)       .                .          .               .              .          .               .              .           				bitsleft -= OFFSET_TABLEBITS;
      372 ( 0.00%)      93 ( 0.00%)       .          .               .              .          .               .              .           				entry = d->offset_decode_table[(entry >> 16) +
      279 ( 0.00%)       .                .          .               .              .          .               .              .           					EXTRACT_VARBITS(bitbuf, (entry >> 8) & 0x3F)];
   28,920 ( 0.00%)       .                .          .               .              .          .               .              .           			} else if (unlikely((u8)bitsleft < OFFSET_MAXFASTBITS +
        .                .                .          .               .              .          .               .              .           					    LITLEN_TABLEBITS - PRELOAD_SLACK))
    1,230 ( 0.00%)     123 ( 0.00%)       0          1 ( 0.01%)      3 ( 0.00%)     0          1 ( 0.02%)      3 ( 0.01%)     .           				REFILL_BITS_IN_FASTLOOP();
        .                .                .          .               .              .          .               .              .           		} else {
        .                .                .          .               .              .          .               .              .           			/* Decoding a match offset on a 32-bit platform */
        .                .                .          .               .              .          .               .              .           			REFILL_BITS_IN_FASTLOOP();
        .                .                .          .               .              .          .               .              .           			if (unlikely(entry & HUFFDEC_EXCEPTIONAL)) {
        .                .                .          .               .              .          .               .              .           				/* Offset codeword requires a subtable */
        .                .                .          .               .              .          .               .              .           				bitbuf >>= OFFSET_TABLEBITS;
        .                .                .          .               .              .          .               .              .           				bitsleft -= OFFSET_TABLEBITS;
        .                .                .          .               .              .          .               .              .           				entry = d->offset_decode_table[(entry >> 16) +
-- line 532 ----------------------------------------
-- line 536 ----------------------------------------
        .                .                .          .               .              .          .               .              .           				STATIC_ASSERT(CAN_CONSUME(
        .                .                .          .               .              .          .               .              .           					OFFSET_MAXBITS - OFFSET_TABLEBITS));
        .                .                .          .               .              .          .               .              .           			} else {
        .                .                .          .               .              .          .               .              .           				/* No refill needed before extra bits */
        .                .                .          .               .              .          .               .              .           				STATIC_ASSERT(CAN_CONSUME(OFFSET_MAXFASTBITS));
        .                .                .          .               .              .          .               .              .           			}
        .                .                .          .               .              .          .               .              .           		}
        .                .                .          .               .              .          .               .              .           		saved_bitbuf = bitbuf;
   14,553 ( 0.00%)       .                .          .               .              .          .               .              .           		bitbuf >>= (u8)entry;
   14,553 ( 0.00%)       .                .          .               .              .          .               .              .           		bitsleft -= entry; /* optimization: subtract full entry */
   29,106 ( 0.00%)       .                .          .               .              .          .               .              .           		offset = entry >> 16;
   43,659 ( 0.00%)       0                0          1 ( 0.01%)      0              0          1 ( 0.02%)      .              .           		offset += EXTRACT_VARBITS8(saved_bitbuf, entry) >> (u8)(entry >> 8);
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		/* Validate the match offset; needed even in the fastloop. */
   58,212 ( 0.00%)  14,553 ( 0.00%)       .          .               .              .          .               .              .           		SAFETY_CHECK(offset <= out_next - (const u8 *)out);
   29,106 ( 0.00%)       .                .          .               .              .          .               .              .           		src = out_next - offset;
        .                .                .          .               .              .          .               .              .           		dst = out_next;
   14,553 ( 0.00%)       0                0          1 ( 0.01%)      0              0          1 ( 0.02%)      .              .           		out_next += length;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		/*
        .                .                .          .               .              .          .               .              .           		 * Before starting to issue the instructions to copy the match,
        .                .                .          .               .              .          .               .              .           		 * refill the bitbuffer and preload the litlen decode table
        .                .                .          .               .              .          .               .              .           		 * entry for the next loop iteration.  This can increase
        .                .                .          .               .              .          .               .              .           		 * performance by allowing the latency of the match copy to
        .                .                .          .               .              .          .               .              .           		 * overlap with these other operations.  To further reduce
        .                .                .          .               .              .          .               .              .           		 * latency, we've arranged for there to be enough bits remaining
-- line 561 ----------------------------------------
-- line 563 ----------------------------------------
        .                .                .          .               .              .          .               .              .           		 * on 32-bit platforms using the byte-at-a-time refill method.
        .                .                .          .               .              .          .               .              .           		 */
        .                .                .          .               .              .          .               .              .           		if (!CAN_CONSUME_AND_THEN_PRELOAD(
        .                .                .          .               .              .          .               .              .           			MAX(OFFSET_MAXBITS - OFFSET_TABLEBITS,
        .                .                .          .               .              .          .               .              .           			    OFFSET_MAXFASTBITS),
        .                .                .          .               .              .          .               .              .           			LITLEN_TABLEBITS) &&
        .                .                .          .               .              .          .               .              .           		    unlikely((u8)bitsleft < LITLEN_TABLEBITS - PRELOAD_SLACK))
        .                .                .          .               .              .          .               .              .           			REFILL_BITS_IN_FASTLOOP();
   43,659 ( 0.00%)  14,553 ( 0.00%)       0          0               1 ( 0.00%)     .          .               .              .           		entry = d->u.litlen_decode_table[bitbuf & litlen_tablemask];
  130,989 ( 0.00%)  14,553 ( 0.00%)      12 ( 0.00%) 1 ( 0.01%)    649 ( 0.00%)     0          1 ( 0.02%)    649 ( 1.59%)     .           		REFILL_BITS_IN_FASTLOOP();
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		/*
        .                .                .          .               .              .          .               .              .           		 * Copy the match.  On most CPUs the fastest method is a
        .                .                .          .               .              .          .               .              .           		 * word-at-a-time copy, unconditionally copying about 5 words
        .                .                .          .               .              .          .               .              .           		 * since this is enough for most matches without being too much.
        .                .                .          .               .              .          .               .              .           		 *
        .                .                .          .               .              .          .               .              .           		 * The normal word-at-a-time copy works for offset >= WORDBYTES,
        .                .                .          .               .              .          .               .              .           		 * which is most cases.  The case of offset == 1 is also common
-- line 580 ----------------------------------------
-- line 582 ----------------------------------------
        .                .                .          .               .              .          .               .              .           		 * the previous byte, which is the result of compressing long
        .                .                .          .               .              .          .               .              .           		 * runs of the same byte.
        .                .                .          .               .              .          .               .              .           		 *
        .                .                .          .               .              .          .               .              .           		 * Writing past the match 'length' is allowed here, since it's
        .                .                .          .               .              .          .               .              .           		 * been ensured there is enough output space left for a slight
        .                .                .          .               .              .          .               .              .           		 * overrun.  FASTLOOP_MAX_BYTES_WRITTEN needs to be updated if
        .                .                .          .               .              .          .               .              .           		 * the maximum possible overrun here is changed.
        .                .                .          .               .              .          .               .              .           		 */
   29,106 ( 0.00%)       .                .          .               .              .          .               .              .           		if (UNALIGNED_ACCESS_IS_FAST && offset >= WORDBYTES) {
   14,431 ( 0.00%)  14,431 ( 0.00%)       0          1 ( 0.01%)  3,776 ( 0.01%)     0          1 ( 0.02%)      .              .           			store_word_unaligned(load_word_unaligned(src), dst);
        .                .                .          .               .              .          .               .              .           			src += WORDBYTES;
        .                .                .          .               .              .          .               .              .           			dst += WORDBYTES;
   14,431 ( 0.00%)  14,431 ( 0.00%)       0          0             446 ( 0.00%)     .          .               .              .           			store_word_unaligned(load_word_unaligned(src), dst);
        .                .                .          .               .              .          .               .              .           			src += WORDBYTES;
        .                .                .          .               .              .          .               .              .           			dst += WORDBYTES;
   14,431 ( 0.00%)  14,431 ( 0.00%)       0          0             429 ( 0.00%)     .          .               .              .           			store_word_unaligned(load_word_unaligned(src), dst);
        .                .                .          .               .              .          .               .              .           			src += WORDBYTES;
        .                .                .          .               .              .          .               .              .           			dst += WORDBYTES;
   14,431 ( 0.00%)  14,431 ( 0.00%)       0          0             436 ( 0.00%)     .          .               .              .           			store_word_unaligned(load_word_unaligned(src), dst);
        .                .                .          .               .              .          .               .              .           			src += WORDBYTES;
        .                .                .          .               .              .          .               .              .           			dst += WORDBYTES;
   14,431 ( 0.00%)  14,431 ( 0.00%)       0          0             413 ( 0.00%)     .          .               .              .           			store_word_unaligned(load_word_unaligned(src), dst);
   14,431 ( 0.00%)       .                .          .               .              .          .               .              .           			src += WORDBYTES;
   14,431 ( 0.00%)       .                .          .               .              .          .               .              .           			dst += WORDBYTES;
   29,033 ( 0.00%)       0                0          2 ( 0.03%)      0              0          2 ( 0.05%)      .              .           			while (dst < out_next) {
       46 ( 0.00%)      32 ( 0.00%)       0          1 ( 0.01%)      5 ( 0.00%)     0          1 ( 0.02%)      .              .           				store_word_unaligned(load_word_unaligned(src), dst);
        .                .                .          .               .              .          .               .              .           				src += WORDBYTES;
        .                .                .          .               .              .          .               .              .           				dst += WORDBYTES;
        4 ( 0.00%)       4 ( 0.00%)       0          0               1 ( 0.00%)     .          .               .              .           				store_word_unaligned(load_word_unaligned(src), dst);
        .                .                .          .               .              .          .               .              .           				src += WORDBYTES;
        .                .                .          .               .              .          .               .              .           				dst += WORDBYTES;
        4 ( 0.00%)       4 ( 0.00%)       .          .               .              .          .               .              .           				store_word_unaligned(load_word_unaligned(src), dst);
        .                .                .          .               .              .          .               .              .           				src += WORDBYTES;
        .                .                .          .               .              .          .               .              .           				dst += WORDBYTES;
        4 ( 0.00%)       4 ( 0.00%)       0          0               2 ( 0.00%)     .          .               .              .           				store_word_unaligned(load_word_unaligned(src), dst);
        .                .                .          .               .              .          .               .              .           				src += WORDBYTES;
        .                .                .          .               .              .          .               .              .           				dst += WORDBYTES;
        4 ( 0.00%)       4 ( 0.00%)       0          2 ( 0.03%)      0              0          1 ( 0.02%)      .              .           				store_word_unaligned(load_word_unaligned(src), dst);
        .                .                .          .               .              .          .               .              .           				src += WORDBYTES;
        .                .                .          .               .              .          .               .              .           				dst += WORDBYTES;
        .                .                .          .               .              .          .               .              .           			}
      244 ( 0.00%)       .                .          .               .              .          .               .              .           		} else if (UNALIGNED_ACCESS_IS_FAST && offset == 1) {
        .                .                .          .               .              .          .               .              .           			machine_word_t v;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           			/*
        .                .                .          .               .              .          .               .              .           			 * This part tends to get auto-vectorized, so keep it
        .                .                .          .               .              .          .               .              .           			 * copying a multiple of 16 bytes at a time.
        .                .                .          .               .              .          .               .              .           			 */
       15 ( 0.00%)       3 ( 0.00%)       .          .               .              .          .               .              .           			v = (machine_word_t)0x0101010101010101 * src[0];
        .                .                .          .               .              .          .               .              .           			store_word_unaligned(v, dst);
        .                .                .          .               .              .          .               .              .           			dst += WORDBYTES;
        .                .                .          .               .              .          .               .              .           			store_word_unaligned(v, dst);
        .                .                .          .               .              .          .               .              .           			dst += WORDBYTES;
        .                .                .          .               .              .          .               .              .           			store_word_unaligned(v, dst);
        .                .                .          .               .              .          .               .              .           			dst += WORDBYTES;
        .                .                .          .               .              .          .               .              .           			store_word_unaligned(v, dst);
        3 ( 0.00%)       .                .          .               .              .          .               .              .           			dst += WORDBYTES;
        6 ( 0.00%)       0                0          2 ( 0.03%)      0              0          1 ( 0.02%)      .              .           			while (dst < out_next) {
        .                .                .          .               .              .          .               .              .           				store_word_unaligned(v, dst);
        .                .                .          .               .              .          .               .              .           				dst += WORDBYTES;
        .                .                .          .               .              .          .               .              .           				store_word_unaligned(v, dst);
        .                .                .          .               .              .          .               .              .           				dst += WORDBYTES;
        .                .                .          .               .              .          .               .              .           				store_word_unaligned(v, dst);
        .                .                .          .               .              .          .               .              .           				dst += WORDBYTES;
        .                .                .          .               .              .          .               .              .           				store_word_unaligned(v, dst);
        .                .                .          .               .              .          .               .              .           				dst += WORDBYTES;
        .                .                .          .               .              .          .               .              .           			}
        .                .                .          .               .              .          .               .              .           		} else if (UNALIGNED_ACCESS_IS_FAST) {
      119 ( 0.00%)     119 ( 0.00%)       .          .               .              .          .               .              .           			store_word_unaligned(load_word_unaligned(src), dst);
        .                .                .          .               .              .          .               .              .           			src += offset;
      119 ( 0.00%)       .                .          .               .              .          .               .              .           			dst += offset;
        .                .                .          .               .              .          .               .              .           			store_word_unaligned(load_word_unaligned(src), dst);
        .                .                .          .               .              .          .               .              .           			src += offset;
      238 ( 0.00%)       .                .          .               .              .          .               .              .           			dst += offset;
        .                .                .          .               .              .          .               .              .           			do {
      121 ( 0.00%)     121 ( 0.00%)       .          .               .              .          .               .              .           				store_word_unaligned(load_word_unaligned(src), dst);
        .                .                .          .               .              .          .               .              .           				src += offset;
        .                .                .          .               .              .          .               .              .           				dst += offset;
      121 ( 0.00%)     121 ( 0.00%)       .          .               .              .          .               .              .           				store_word_unaligned(load_word_unaligned(src), dst);
        .                .                .          .               .              .          .               .              .           				src += offset;
      121 ( 0.00%)       .                .          .               .              .          .               .              .           				dst += offset;
      242 ( 0.00%)       .                .          .               .              .          .               .              .           			} while (dst < out_next);
        .                .                .          .               .              .          .               .              .           		} else {
        .                .                .          .               .              .          .               .              .           			*dst++ = *src++;
        .                .                .          .               .              .          .               .              .           			*dst++ = *src++;
        .                .                .          .               .              .          .               .              .           			do {
        .                .                .          .               .              .          .               .              .           				*dst++ = *src++;
        .                .                .          .               .              .          .               .              .           			} while (dst < out_next);
        .                .                .          .               .              .          .               .              .           		}
1,698,900 ( 0.02%) 849,450 ( 0.05%)       0          1 ( 0.01%)      0              0          1 ( 0.02%)      .              .           	} while (in_next < in_fastloop_end && out_next < out_fastloop_end);
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           	/*
        .                .                .          .               .              .          .               .              .           	 * This is the generic loop for decoding literals and matches.  This
        .                .                .          .               .              .          .               .              .           	 * handles cases where in_next and out_next are close to the end of
        .                .                .          .               .              .          .               .              .           	 * their respective buffers.  Usually this loop isn't performance-
        .                .                .          .               .              .          .               .              .           	 * critical, as most time is spent in the fastloop above instead.  We
        .                .                .          .               .              .          .               .              .           	 * therefore omit some optimizations here in favor of smaller code.
        .                .                .          .               .              .          .               .              .           	 */
        .                .                .          .               .              .          .               .              .           generic_loop:
        .                .                .          .               .              .          .               .              .           	for (;;) {
        .                .                .          .               .              .          .               .              .           		u32 length, offset;
        .                .                .          .               .              .          .               .              .           		const u8 *src;
        .                .                .          .               .              .          .               .              .           		u8 *dst;
        .                .                .          .               .              .          .               .              .           
    3,903 ( 0.00%)     274 ( 0.00%)       9 ( 0.00%) 8 ( 0.12%)      5 ( 0.00%)     0          7 ( 0.17%)      3 ( 0.01%)     .           		REFILL_BITS();
      798 ( 0.00%)     532 ( 0.00%)       .          .               .              .          .               .              .           		entry = d->u.litlen_decode_table[bitbuf & litlen_tablemask];
        .                .                .          .               .              .          .               .              .           		saved_bitbuf = bitbuf;
      266 ( 0.00%)       .                .          .               .              .          .               .              .           		bitbuf >>= (u8)entry;
      532 ( 0.00%)       .                .          .               .              .          .               .              .           		bitsleft -= entry;
      532 ( 0.00%)       .                .          .               .              .          .               .              .           		if (unlikely(entry & HUFFDEC_SUBTABLE_POINTER)) {
       54 ( 0.00%)      18 ( 0.00%)       .          .               .              .          .               .              .           			entry = d->u.litlen_decode_table[(entry >> 16) +
       54 ( 0.00%)       0                0          2 ( 0.03%)      0              0          1 ( 0.02%)      .              .           					EXTRACT_VARBITS(bitbuf, (entry >> 8) & 0x3F)];
       18 ( 0.00%)       .                .          .               .              .          .               .              .           			saved_bitbuf = bitbuf;
       36 ( 0.00%)       0                0          2 ( 0.03%)      0              0          1 ( 0.02%)      .              .           			bitbuf >>= (u8)entry;
       18 ( 0.00%)       .                .          .               .              .          .               .              .           			bitsleft -= entry;
        .                .                .          .               .              .          .               .              .           		}
      532 ( 0.00%)       .                .          .               .              .          .               .              .           		length = entry >> 16;
      532 ( 0.00%)       .                .          .               .              .          .               .              .           		if (entry & HUFFDEC_LITERAL) {
      410 ( 0.00%)     205 ( 0.00%)       0          1 ( 0.01%)      0              0          1 ( 0.02%)      .              .           			if (unlikely(out_next == out_end))
        .                .                .          .               .              .          .               .              .           				return LIBDEFLATE_INSUFFICIENT_SPACE;
      410 ( 0.00%)       0              205 ( 0.00%) 0               0              2 ( 0.00%) 0               0              2 ( 0.00%)  			*out_next++ = length;
        .                .                .          .               .              .          .               .              .           			continue;
        .                .                .          .               .              .          .               .              .           		}
      122 ( 0.00%)       0                0          2 ( 0.03%)      0              0          1 ( 0.02%)      .              .           		if (unlikely(entry & HUFFDEC_END_OF_BLOCK))
        .                .                .          .               .              .          .               .              .           			goto block_done;
      118 ( 0.00%)       .                .          .               .              .          .               .              .           		length += EXTRACT_VARBITS8(saved_bitbuf, entry) >> (u8)(entry >> 8);
      295 ( 0.00%)      59 ( 0.00%)       .          .               .              .          .               .              .           		if (unlikely(length > out_end - out_next))
        .                .                .          .               .              .          .               .              .           			return LIBDEFLATE_INSUFFICIENT_SPACE;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		if (!CAN_CONSUME(LENGTH_MAXBITS + OFFSET_MAXBITS))
        .                .                .          .               .              .          .               .              .           			REFILL_BITS();
      118 ( 0.00%)      59 ( 0.00%)       .          .               .              .          .               .              .           		entry = d->offset_decode_table[bitbuf & BITMASK(OFFSET_TABLEBITS)];
      118 ( 0.00%)       .                .          .               .              .          .               .              .           		if (unlikely(entry & HUFFDEC_EXCEPTIONAL)) {
        .                .                .          .               .              .          .               .              .           			bitbuf >>= OFFSET_TABLEBITS;
        .                .                .          .               .              .          .               .              .           			bitsleft -= OFFSET_TABLEBITS;
        .                .                .          .               .              .          .               .              .           			entry = d->offset_decode_table[(entry >> 16) +
        .                .                .          .               .              .          .               .              .           					EXTRACT_VARBITS(bitbuf, (entry >> 8) & 0x3F)];
        .                .                .          .               .              .          .               .              .           			if (!CAN_CONSUME(OFFSET_MAXBITS))
        .                .                .          .               .              .          .               .              .           				REFILL_BITS();
        .                .                .          .               .              .          .               .              .           		}
      118 ( 0.00%)       .                .          .               .              .          .               .              .           		offset = entry >> 16;
      118 ( 0.00%)       0                0          2 ( 0.03%)      0              0          1 ( 0.02%)      .              .           		offset += EXTRACT_VARBITS8(bitbuf, entry) >> (u8)(entry >> 8);
       59 ( 0.00%)       .                .          .               .              .          .               .              .           		bitbuf >>= (u8)entry;
       59 ( 0.00%)       .                .          .               .              .          .               .              .           		bitsleft -= entry;
        .                .                .          .               .              .          .               .              .           
      354 ( 0.00%)      59 ( 0.00%)       .          .               .              .          .               .              .           		SAFETY_CHECK(offset <= out_next - (const u8 *)out);
      236 ( 0.00%)       .                .          .               .              .          .               .              .           		src = out_next - offset;
        .                .                .          .               .              .          .               .              .           		dst = out_next;
      177 ( 0.00%)       .                .          .               .              .          .               .              .           		out_next += length;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		STATIC_ASSERT(DEFLATE_MIN_MATCH_LEN == 3);
      295 ( 0.00%)      59 ( 0.00%)     118 ( 0.00%) 0               4 ( 0.00%)     2 ( 0.00%) 0               0              2 ( 0.00%)  		*dst++ = *src++;
      531 ( 0.00%)     118 ( 0.00%)     118 ( 0.00%) 2 ( 0.03%)      0              0          1 ( 0.02%)      .              .           		*dst++ = *src++;
        .                .                .          .               .              .          .               .              .           		do {
      270 ( 0.00%)     270 ( 0.00%)     270 ( 0.00%) 0               0              5 ( 0.00%) 0               0              5 ( 0.00%)  			*dst++ = *src++;
      593 ( 0.00%)       .                .          .               .              .          .               .              .           		} while (dst < out_next);
        .                .                .          .               .              .          .               .              .           	}
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           block_done:
        .                .                .          .               .              .          .               .              .           	/* Finished decoding a block */
        .                .                .          .               .              .          .               .              .           
       24 ( 0.00%)      12 ( 0.00%)       0          1 ( 0.01%)      0              0          1 ( 0.02%)      .              .           	if (!is_final_block)
        .                .                .          .               .              .          .               .              .           		goto next_block;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           	/* That was the last block. */
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           	bitsleft = (u8)bitsleft;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           	/*
        .                .                .          .               .              .          .               .              .           	 * If any of the implicit appended zero bytes were consumed (not just
        .                .                .          .               .              .          .               .              .           	 * refilled) before hitting end of stream, then the data is bad.
        .                .                .          .               .              .          .               .              .           	 */
       12 ( 0.00%)       2 ( 0.00%)       .          .               .              .          .               .              .           	SAFETY_CHECK(overread_count <= (bitsleft >> 3));
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           	/* Optionally return the actual number of bytes consumed. */
        6 ( 0.00%)       2 ( 0.00%)       0          0               2 ( 0.00%)     .          .               .              .           	if (actual_in_nbytes_ret) {
        .                .                .          .               .              .          .               .              .           		/* Don't count bytes that were refilled but not consumed. */
        .                .                .          .               .              .          .               .              .           		in_next -= (bitsleft >> 3) - overread_count;
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           		*actual_in_nbytes_ret = in_next - (u8 *)in;
        .                .                .          .               .              .          .               .              .           	}
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           	/* Optionally return the actual number of bytes written. */
        4 ( 0.00%)       2 ( 0.00%)       0          0               2 ( 0.00%)     .          .               .              .           	if (actual_out_nbytes_ret) {
        8 ( 0.00%)       4 ( 0.00%)       2 ( 0.00%) 0               0              2 ( 0.00%) .               .              .           		*actual_out_nbytes_ret = out_next - (u8 *)out;
        .                .                .          .               .              .          .               .              .           	} else {
        .                .                .          .               .              .          .               .              .           		if (out_next != out_end)
        .                .                .          .               .              .          .               .              .           			return LIBDEFLATE_SHORT_OUTPUT;
        .                .                .          .               .              .          .               .              .           	}
        4 ( 0.00%)       .                .          .               .              .          .               .              .           	return LIBDEFLATE_SUCCESS;
       16 ( 0.00%)      14 ( 0.00%)       0          0               2 ( 0.00%)     .          .               .              .           }
        .                .                .          .               .              .          .               .              .           
        .                .                .          .               .              .          .               .              .           #undef FUNCNAME
        .                .                .          .               .              .          .               .              .           #undef ATTRIBUTES
        .                .                .          .               .              .          .               .              .           #undef EXTRACT_VARBITS
        .                .                .          .               .              .          .               .              .           #undef EXTRACT_VARBITS8

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /rust/deps/hashbrown-0.15.4/src/control/bitmask.rs
  /rust/deps/hashbrown-0.15.4/src/control/tag.rs
  /rust/deps/hashbrown-0.15.4/src/map.rs
  /rust/deps/hashbrown-0.15.4/src/raw/mod.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/alloc/src/raw_vec/mod.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/alloc/src/vec/into_iter.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/alloc/src/vec/mod.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/../../stdarch/crates/core_arch/src/x86/sse2.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/alloc/layout.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/cmp.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/convert/num.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/hash/sip.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/intrinsics/mod.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/iter/range.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/num/nonzero.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/num/uint_macros.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ops/index_range.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ptr/const_ptr.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ptr/mod.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ptr/mut_ptr.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ptr/non_null.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/slice/index.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/slice/iter/macros.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/slice/sort/shared/smallsort.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/slice/sort/unstable/quicksort.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/std/src/collections/hash/map.rs
  /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/std/src/sys/alloc/unix.rs

--------------------------------------------------------------------------------
Ir                     Dr                   Dw                  I1mr         D1mr            D1mw            ILmr        DLmr            DLmw            
--------------------------------------------------------------------------------
2,405,148,149 (23.04%) 130,728,186 ( 7.05%) 35,385,855 ( 3.65%) 107 ( 1.55%) 28,303 ( 0.05%) 17,314 ( 0.26%) 94 ( 2.32%) 19,771 (48.53%) 17,251 ( 0.75%)  events annotated

